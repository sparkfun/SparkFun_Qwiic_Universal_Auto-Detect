{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SparkFun Qwiic Universal Auto-Detect SparkFun ESP32 Thing Plus C (SPX-18018) The SparkFun Qwiic Universal Auto-Detect library makes it easy to create a scalable Qwiic (I 2 C) sensing and logging device on a wide range of platforms. Key Features Automatic detection of a wide range of Qwiic sensors Built-in Qwiic Mux support Only one library to install This library contains automatically-updated copies of all the necessary sensor libraries Adding new sensors is easy There is only one file to add and three files to modify when adding a new sensor Built-in menu system The sensor and menu configuration can be stored in: EEPROM LittleFS SD or microSD card: both SD and SdFat are supported Getting Started The Getting Started Page outlines library installation and the general use of the SparkFun Qwiic Universal Auto-Detect library. Detailed examples are included as part of the library installation process and available in the Arduino IDE File > Examples > menu. A walk-thru of key examples is contained in the Examples section of this documentation set. A full API Reference is also provided for the library. Supported Sensors Pressure, Altitude, Humidity and Temperature Data: AHT20 humidity and temperature sensor BME280 atmospheric sensor LPS25HB absolute pressure sensor MPR0025PA MicroPressure sensor MS5637 barometric pressure sensor MS8607 PHT sensor SDP31 differential pressure sensor SHTC3 humidity and temperature sensor Air Quality and Environmental Sensors: CCS811 air quality sensor SCD30 CO 2 humidity and temperature sensor SCD40 CO 2 humidity and temperature sensor SGP30 air quality and Volatile Organic Compound (VOC) sensor SGP40 air quality (VOC Index) Sensor STC31 CO 2 sensor VEML6075 UV light sensor VEML7700 ambient light sensor Precision Temperature Sensors: Qwiic PT100 ADS122C04 platinum resistance sensor MCP9600 thermocouple amplifier TMP117 precision temperature sensor Global Navigation Satellite System (GNSS) navigation data: SFE QUAD can be linked to any of SparkFun\u2019s u-blox GNSS boards allowing you to log accurate position, velocity and time data Distance: VCNL4040 proximity sensor VL53L1X laser Time of Flight (ToF) sensor Weight: NAU7802 load cell sensor Battery Condition: MAX17048 fuel gauge Waypoint / Event logging: Qwiic Button Tested Platforms ESP32 with microSD ESP32 with EEPROM or LittleFS Artemis (Apollo3) with EEPROM SAMD21 with FlashAsEEPROM_SAMD as EEPROM SAMD51 with FlashAsEEPROM_SAMD as EEPROM STM32 with FlashStorage_STM32 as EEPROM RP2040 with microSD following the instructions in the Hookup Guide and using the pin definitions shown below: // pins_arduino.h : pin definitions for the RP2040 Thing Plus (DEV-17745) // SPI #define PIN_SPI_MISO (12u) #define PIN_SPI_MOSI (15u) #define PIN_SPI_SCK (14u) #define PIN_SPI_SS (9u) // Wire #define PIN_WIRE_SDA (6u) #define PIN_WIRE_SCL (7u) License SparkFun Qwiic Universal Auto-Detect is licensed using the Open Source MIT License","title":"Home"},{"location":"#sparkfun-qwiic-universal-auto-detect","text":"SparkFun ESP32 Thing Plus C (SPX-18018) The SparkFun Qwiic Universal Auto-Detect library makes it easy to create a scalable Qwiic (I 2 C) sensing and logging device on a wide range of platforms.","title":"SparkFun Qwiic Universal Auto-Detect"},{"location":"#key-features","text":"Automatic detection of a wide range of Qwiic sensors Built-in Qwiic Mux support Only one library to install This library contains automatically-updated copies of all the necessary sensor libraries Adding new sensors is easy There is only one file to add and three files to modify when adding a new sensor Built-in menu system The sensor and menu configuration can be stored in: EEPROM LittleFS SD or microSD card: both SD and SdFat are supported","title":"Key Features"},{"location":"#getting-started","text":"The Getting Started Page outlines library installation and the general use of the SparkFun Qwiic Universal Auto-Detect library. Detailed examples are included as part of the library installation process and available in the Arduino IDE File > Examples > menu. A walk-thru of key examples is contained in the Examples section of this documentation set. A full API Reference is also provided for the library.","title":"Getting Started"},{"location":"#supported-sensors","text":"Pressure, Altitude, Humidity and Temperature Data: AHT20 humidity and temperature sensor BME280 atmospheric sensor LPS25HB absolute pressure sensor MPR0025PA MicroPressure sensor MS5637 barometric pressure sensor MS8607 PHT sensor SDP31 differential pressure sensor SHTC3 humidity and temperature sensor Air Quality and Environmental Sensors: CCS811 air quality sensor SCD30 CO 2 humidity and temperature sensor SCD40 CO 2 humidity and temperature sensor SGP30 air quality and Volatile Organic Compound (VOC) sensor SGP40 air quality (VOC Index) Sensor STC31 CO 2 sensor VEML6075 UV light sensor VEML7700 ambient light sensor Precision Temperature Sensors: Qwiic PT100 ADS122C04 platinum resistance sensor MCP9600 thermocouple amplifier TMP117 precision temperature sensor Global Navigation Satellite System (GNSS) navigation data: SFE QUAD can be linked to any of SparkFun\u2019s u-blox GNSS boards allowing you to log accurate position, velocity and time data Distance: VCNL4040 proximity sensor VL53L1X laser Time of Flight (ToF) sensor Weight: NAU7802 load cell sensor Battery Condition: MAX17048 fuel gauge Waypoint / Event logging: Qwiic Button","title":"Supported Sensors"},{"location":"#tested-platforms","text":"ESP32 with microSD ESP32 with EEPROM or LittleFS Artemis (Apollo3) with EEPROM SAMD21 with FlashAsEEPROM_SAMD as EEPROM SAMD51 with FlashAsEEPROM_SAMD as EEPROM STM32 with FlashStorage_STM32 as EEPROM RP2040 with microSD following the instructions in the Hookup Guide and using the pin definitions shown below: // pins_arduino.h : pin definitions for the RP2040 Thing Plus (DEV-17745) // SPI #define PIN_SPI_MISO (12u) #define PIN_SPI_MOSI (15u) #define PIN_SPI_SCK (14u) #define PIN_SPI_SS (9u) // Wire #define PIN_WIRE_SDA (6u) #define PIN_WIRE_SCL (7u)","title":"Tested Platforms"},{"location":"#license","text":"SparkFun Qwiic Universal Auto-Detect is licensed using the Open Source MIT License","title":"License"},{"location":"api_SFE_QUAD_Menu/","text":"API Reference for the SFE_QUAD_Menu class Brief Overview The SFE_QUAD_Menu class allows the user to create a menu as a linked-list of SFE_QUAD_Menu_Item objects. The SFE_QUAD_Menu _head points to the head (start) of the linked list. _next points to the next SFE_QUAD_Menu_Item in the list. The _next of the final SFE_QUAD_Menu_Item in the list is NULL . _head is initially NULL . It is set to the address of the first SFE_QUAD_Menu_Item when addMenuItem is called. There are several different types of menu item, as defined by the SFE_QUAD_Menu_Variable_Type_e enum: SFE_QUAD_MENU_VARIABLE_TYPE_NONE contains only the _itemName as text The name of the menu and perhaps some underscoring can be defined using this type This can be used to include 'empty' lines to separate parts of the menu SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START is a special type which defines the start of a sub-menu Only this line is printed when the parent menu is displayed The menu items within the sub-menu are only printed when the sub-menu is opened openMenu is called recursively to enter the sub-menus SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_END marks the end of a sub-menu SFE_QUAD_MENU_VARIABLE_TYPE_CODE contains a pointer to a method which is called when this menu item is selected SFE_QUAD_MENU_VARIABLE_TYPE_TEXT contains ASCII text e.g. a WiFi SSID or password SFE_QUAD_MENU_VARIABLE_TYPE_BOOL is a bool which is toggled when the menu item is selected SFE_QUAD_MENU_VARIABLE_TYPE_FLOAT contains a float There is an equivalent type for double SFE_QUAD_MENU_VARIABLE_TYPE_INT contains a signed integer int There are equivalent types for uint8_t , uint16_t , uint32_t , unsigned long and long Menu items are added with addMenuItem . An overloaded method allows CODE items to be added. The menu variable can be read with getMenuItemVariable . The value is returned in a SFE_QUAD_Menu_Every_Type_t . An overloaded method allows TEXT values to be read. The menu variable can be set with setMenuItemVariable , typically to set its default or initial value. An overloaded method allows TEXT to be set with a const char * . Numeric menu items can have minimum and maximum values assigned using setMenuItemVariableMin and setMenuItemVariableMax . The built-in getValueDouble method will then only allow values between the min and max to be entered. setMenuPort defines which Stream (Serial port) will be used for the menu. Debug messages can be displayed if required. setDebugPort sets the Stream (Serial port) for those. The SFE_QUAD_Menu is not aware of what storage medium is being used by SFE_QUAD_Sensors . The menu variables can be extracted as CSV text using getMenuVariableAsCSV . Higher methods are then responsible for writing that text to storage. Likewise, higher methods will read the menu variables from storage as CSV text. updateMenuVariableFromCSV will update the variable of the appropriate menu item using that text. Initialization / Configuration setMenuPort() This method sets the Stream (Serial port) for the menu. The supportsBackspace parameter can be set to true if the user is using a terminal emulator, like Tera Term, which supports backspace. Existing TEXT items can then be edited instead of having to be entered in full each time. void setMenuPort ( Stream & port , bool supportsBackspace ) Parameter Type Description port Stream & The address of the Stream (Serial port) supportsBackspace bool Default is false . If true , existing TEXT items can be edited setDebugPort() This method sets the Stream (Serial port) for menu debug messages - if desired. void setDebugPort ( Stream & port ) Parameter Type Description port Stream & The address of the Stream (Serial port) addMenuItem() This method adds a menu item of the specified type to the linked-list. bool addMenuItem ( const char * itemName , SFE_QUAD_Menu_Variable_Type_e variableType ) Parameter Type Description itemName const char * The name of the menu item - the text that will be printed when this menu item is shown variableType SFE_QUAD_Menu_Variable_Type_e The variable type associated with this menu item return value bool true if the item is added successfully, otherwise false addMenuItem() This method allows CODE menu items to be added. bool addMenuItem ( const char * itemName , void ( * codePointer )()) Parameter Type Description itemName const char * The name of the menu item - the text that will be printed when this menu item is shown codePointer void (*)() The address of the method to be called when this menu item is selected return value bool true if the item is added successfully, otherwise false getMenuItemVariableType() This method returns the variable type of this menu item. SFE_QUAD_Menu_Variable_Type_e getMenuItemVariableType ( const char * itemName ) Parameter Type Description itemName const char * The name of the menu item return value SFE_QUAD_Menu_Variable_Type_e The enum value representing the type getMenuItemVariable() This method returns the value of the menu item variable. bool getMenuItemVariable ( const char * itemName , SFE_QUAD_Menu_Every_Type_t * theValue ) Parameter Type Description itemName const char * The name of the menu item theValue SFE_QUAD_Menu_Every_Type_t * A pointer to the struct that will hold the value return value bool true if the item exists and the value is retrieved successfully, otherwise false getMenuItemVariable() This method returns the value of a TEXT menu item variable. The text is copied into theValue . maxLen should be set to the size of theValue . The text is only copied if theValue is large enough to hold it. bool getMenuItemVariable ( const char * itemName , char * theValue , size_t maxLen ) Parameter Type Description itemName const char * The name of the menu item theValue char * A pointer to the char array that will hold the text maxLen size_t Defines how many characters theValue can hold return value bool true if the item exists and the value is retrieved successfully, otherwise false setMenuItemVariable() This method sets the menu item variable in the linked-list with the value passed in theValue . bool setMenuItemVariable ( const char * itemName , const SFE_QUAD_Menu_Every_Type_t * theValue ) Parameter Type Description itemName const char * The name of the menu item theValue const SFE_QUAD_Menu_Every_Type_t * A pointer to the struct holding the value return value bool true if the item exists and the value is updated successfully, otherwise false setMenuItemVariable() This method sets the menu item variable in the linked-list with the TEXT passed in theValue . bool setMenuItemVariable ( const char * itemName , const char * theValue ) Parameter Type Description itemName const char * The name of the menu item theValue const char * A pointer to the text to be copied into the value return value bool true if the item exists and the text is copied successfully, otherwise false setMenuItemVariableMin() This method sets the minimum permissible value for the menu item variable. This is used by the menu to check the value is in range . bool setMenuItemVariableMin ( const char * itemName , const SFE_QUAD_Menu_Every_Type_t * minVal ) Parameter Type Description itemName const char * The name of the menu item minVal const SFE_QUAD_Menu_Every_Type_t * A pointer to the struct holding the minimum value return value bool true if the item exists and the minimum value is updated successfully, otherwise false setMenuItemVariableMax() This method sets the maximum permissible value for the menu item variable. This is used by the menu to check the value is in range . bool setMenuItemVariableMax ( const char * itemName , const SFE_QUAD_Menu_Every_Type_t * maxVal ) Parameter Type Description itemName const char * The name of the menu item maxVal const SFE_QUAD_Menu_Every_Type_t * A pointer to the struct holding the maximum value return value bool true if the item exists and the maximum value is updated successfully, otherwise false The Menu openMenu() This method opens the menu on the chosen Stream (Serial port). This method calls itself recursively when entering a sub-menu. start points to the address of the SUB_MENU_START menu item. If start is NULL (the default), the menu starts at _head . bool openMenu ( SFE_QUAD_Menu_Item * start ) Parameter Type Description start SFE_QUAD_Menu_Item * The address of the menu item to be shown first return value bool true if the menu item exists and the menu closes normally, otherwise false Menu Item Variable Storage getNumMenuVariables() The method returns the number of menu item variables which should be written to storage. The return value dictates how many time getMenuVariableAsCSV is called. uint16_t getNumMenuVariables ( void ) Parameter Type Description return value uint16_t The number of menu item variables requiring storage getMenuVariableAsCSV() This method reads the menu item variable with index num and writes its name, type and value into var as CSV-format text. Higher methods then write that CSV text to storage. maxLen defines how many characters var can hold. The text is not written if var is too small. bool getMenuVariableAsCSV ( uint16_t num , char * var , size_t maxLen ) Parameter Type Description num uint16_t The menu item index var char * A pointer to a char array that the CSV text will be written to maxLen size_t The maximum number of characters var can hold return value bool true if the item exists and is copied successfully, otherwise false updateMenuVariableFromCSV() line contains a menu variable in CSV format which has been read from storage. This method updates the appropriate menu item variable with the value contained in the CSV text. bool updateMenuVariableFromCSV ( char * line ) Parameter Type Description line char * A pointer to a char array that contains the CSV return value bool true if the menu item exists and is updated successfully, otherwise false Helper Methods getMenuChoice() Ask the user to select a menu item. uint32_t getMenuChoice ( unsigned long timeout ) Parameter Type Description timeout unsigned long The timeout in milliseconds return value uint32_t The menu item selected, 0 if none or if a timeout occurred getValueDouble() Ask the user to enter an integer or floating point value. Exponent-format values are also acceptable. bool getValueDouble ( double * value , unsigned long timeout ) Parameter Type Description timeout unsigned long The timeout in milliseconds value double * A pointer to the double which will hold the value return value uint32_t false if nothing is entered or a timeout occurred, otherwise true getValueText() Ask the user to enter a TEXT entry, such as a WiFi password. getValueText will automatically create a new char array to hold the text and returns a pointer to it. The old char array is automatically deleted (freed). bool getValueText ( char ** value , unsigned long timeout ) Parameter Type Description timeout unsigned long The timeout in milliseconds value char * * A pointer to a pointer to the dynamic char array that holds the text return value uint32_t true if text is entered within the timeout, otherwise false getMenuItemNameMaxLen() Returns the maximum length of all of the menu item names. Used to format the menus correctly (space padding). size_t getMenuItemNameMaxLen ( void ) Parameter Type Description return value size_t The maximum name length getMenuVariablesMaxLen() Returns the likely maximum combined length of a full menu item (including min and max values if present). This is used to determine how much memory should be allocated to hold a menu item in CSV format. size_t getMenuVariablesMaxLen ( void ) Parameter Type Description return value size_t The likely maximum length menuItemExists() Returns a pointer to the menu item if it exists, otherwise returns NULL . SFE_QUAD_Menu_Item * menuItemExists ( const char * itemName ) Parameter Type Description itemName const char * The item name return value SFE_QUAD_Menu_Item * A pointer to the menu item (if it exists), otherwise NULL setMenuTimeout() This method sets the menu timeout. void setMenuTimeout ( unsigned long newTimeout ) Parameter Type Description newTimeout unsigned long The new menu timeout in milliseconds setMaxTextChars() This method sets the maximum number of characters that can be entered into a TEXT value. void setMaxTextChars ( uint16_t newMax ) Parameter Type Description newMax uint16_t The new maximum length setSupportsBackspace() This method defines if the _menuPort supports backspace for TEXT entry. void setSupportsBackspace ( bool support ) Parameter Type Description support bool true in the port supports backspace, otherwise false Member Variables Parameter Type Description _head SFE_QUAD_Menu_Item * A pointer to the first menu item in the linked-list, initially NULL _menuPort Stream * The address of the Stream (Serial port) to be used by the menu _debugPort Stream * The address of the Stream (Serial port) to be used for debug messages (if desired) _menuTimeout unsigned long The default menu timeout in milliseconds. Default is 10000 _maxTextChars uint16_t The maximum length of TEXT value entries. Default is 32 _supportsBackspace bool true if the port supports backspace, otherwise false . Default is false","title":"SFE_QUAD_Menu"},{"location":"api_SFE_QUAD_Menu/#api-reference-for-the-sfe_quad_menu-class","text":"","title":"API Reference for the SFE_QUAD_Menu class"},{"location":"api_SFE_QUAD_Menu/#brief-overview","text":"The SFE_QUAD_Menu class allows the user to create a menu as a linked-list of SFE_QUAD_Menu_Item objects. The SFE_QUAD_Menu _head points to the head (start) of the linked list. _next points to the next SFE_QUAD_Menu_Item in the list. The _next of the final SFE_QUAD_Menu_Item in the list is NULL . _head is initially NULL . It is set to the address of the first SFE_QUAD_Menu_Item when addMenuItem is called. There are several different types of menu item, as defined by the SFE_QUAD_Menu_Variable_Type_e enum: SFE_QUAD_MENU_VARIABLE_TYPE_NONE contains only the _itemName as text The name of the menu and perhaps some underscoring can be defined using this type This can be used to include 'empty' lines to separate parts of the menu SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START is a special type which defines the start of a sub-menu Only this line is printed when the parent menu is displayed The menu items within the sub-menu are only printed when the sub-menu is opened openMenu is called recursively to enter the sub-menus SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_END marks the end of a sub-menu SFE_QUAD_MENU_VARIABLE_TYPE_CODE contains a pointer to a method which is called when this menu item is selected SFE_QUAD_MENU_VARIABLE_TYPE_TEXT contains ASCII text e.g. a WiFi SSID or password SFE_QUAD_MENU_VARIABLE_TYPE_BOOL is a bool which is toggled when the menu item is selected SFE_QUAD_MENU_VARIABLE_TYPE_FLOAT contains a float There is an equivalent type for double SFE_QUAD_MENU_VARIABLE_TYPE_INT contains a signed integer int There are equivalent types for uint8_t , uint16_t , uint32_t , unsigned long and long Menu items are added with addMenuItem . An overloaded method allows CODE items to be added. The menu variable can be read with getMenuItemVariable . The value is returned in a SFE_QUAD_Menu_Every_Type_t . An overloaded method allows TEXT values to be read. The menu variable can be set with setMenuItemVariable , typically to set its default or initial value. An overloaded method allows TEXT to be set with a const char * . Numeric menu items can have minimum and maximum values assigned using setMenuItemVariableMin and setMenuItemVariableMax . The built-in getValueDouble method will then only allow values between the min and max to be entered. setMenuPort defines which Stream (Serial port) will be used for the menu. Debug messages can be displayed if required. setDebugPort sets the Stream (Serial port) for those. The SFE_QUAD_Menu is not aware of what storage medium is being used by SFE_QUAD_Sensors . The menu variables can be extracted as CSV text using getMenuVariableAsCSV . Higher methods are then responsible for writing that text to storage. Likewise, higher methods will read the menu variables from storage as CSV text. updateMenuVariableFromCSV will update the variable of the appropriate menu item using that text.","title":"Brief Overview"},{"location":"api_SFE_QUAD_Menu/#initialization-configuration","text":"","title":"Initialization / Configuration"},{"location":"api_SFE_QUAD_Menu/#setmenuport","text":"This method sets the Stream (Serial port) for the menu. The supportsBackspace parameter can be set to true if the user is using a terminal emulator, like Tera Term, which supports backspace. Existing TEXT items can then be edited instead of having to be entered in full each time. void setMenuPort ( Stream & port , bool supportsBackspace ) Parameter Type Description port Stream & The address of the Stream (Serial port) supportsBackspace bool Default is false . If true , existing TEXT items can be edited","title":"setMenuPort()"},{"location":"api_SFE_QUAD_Menu/#setdebugport","text":"This method sets the Stream (Serial port) for menu debug messages - if desired. void setDebugPort ( Stream & port ) Parameter Type Description port Stream & The address of the Stream (Serial port)","title":"setDebugPort()"},{"location":"api_SFE_QUAD_Menu/#addmenuitem","text":"This method adds a menu item of the specified type to the linked-list. bool addMenuItem ( const char * itemName , SFE_QUAD_Menu_Variable_Type_e variableType ) Parameter Type Description itemName const char * The name of the menu item - the text that will be printed when this menu item is shown variableType SFE_QUAD_Menu_Variable_Type_e The variable type associated with this menu item return value bool true if the item is added successfully, otherwise false","title":"addMenuItem()"},{"location":"api_SFE_QUAD_Menu/#addmenuitem_1","text":"This method allows CODE menu items to be added. bool addMenuItem ( const char * itemName , void ( * codePointer )()) Parameter Type Description itemName const char * The name of the menu item - the text that will be printed when this menu item is shown codePointer void (*)() The address of the method to be called when this menu item is selected return value bool true if the item is added successfully, otherwise false","title":"addMenuItem()"},{"location":"api_SFE_QUAD_Menu/#getmenuitemvariabletype","text":"This method returns the variable type of this menu item. SFE_QUAD_Menu_Variable_Type_e getMenuItemVariableType ( const char * itemName ) Parameter Type Description itemName const char * The name of the menu item return value SFE_QUAD_Menu_Variable_Type_e The enum value representing the type","title":"getMenuItemVariableType()"},{"location":"api_SFE_QUAD_Menu/#getmenuitemvariable","text":"This method returns the value of the menu item variable. bool getMenuItemVariable ( const char * itemName , SFE_QUAD_Menu_Every_Type_t * theValue ) Parameter Type Description itemName const char * The name of the menu item theValue SFE_QUAD_Menu_Every_Type_t * A pointer to the struct that will hold the value return value bool true if the item exists and the value is retrieved successfully, otherwise false","title":"getMenuItemVariable()"},{"location":"api_SFE_QUAD_Menu/#getmenuitemvariable_1","text":"This method returns the value of a TEXT menu item variable. The text is copied into theValue . maxLen should be set to the size of theValue . The text is only copied if theValue is large enough to hold it. bool getMenuItemVariable ( const char * itemName , char * theValue , size_t maxLen ) Parameter Type Description itemName const char * The name of the menu item theValue char * A pointer to the char array that will hold the text maxLen size_t Defines how many characters theValue can hold return value bool true if the item exists and the value is retrieved successfully, otherwise false","title":"getMenuItemVariable()"},{"location":"api_SFE_QUAD_Menu/#setmenuitemvariable","text":"This method sets the menu item variable in the linked-list with the value passed in theValue . bool setMenuItemVariable ( const char * itemName , const SFE_QUAD_Menu_Every_Type_t * theValue ) Parameter Type Description itemName const char * The name of the menu item theValue const SFE_QUAD_Menu_Every_Type_t * A pointer to the struct holding the value return value bool true if the item exists and the value is updated successfully, otherwise false","title":"setMenuItemVariable()"},{"location":"api_SFE_QUAD_Menu/#setmenuitemvariable_1","text":"This method sets the menu item variable in the linked-list with the TEXT passed in theValue . bool setMenuItemVariable ( const char * itemName , const char * theValue ) Parameter Type Description itemName const char * The name of the menu item theValue const char * A pointer to the text to be copied into the value return value bool true if the item exists and the text is copied successfully, otherwise false","title":"setMenuItemVariable()"},{"location":"api_SFE_QUAD_Menu/#setmenuitemvariablemin","text":"This method sets the minimum permissible value for the menu item variable. This is used by the menu to check the value is in range . bool setMenuItemVariableMin ( const char * itemName , const SFE_QUAD_Menu_Every_Type_t * minVal ) Parameter Type Description itemName const char * The name of the menu item minVal const SFE_QUAD_Menu_Every_Type_t * A pointer to the struct holding the minimum value return value bool true if the item exists and the minimum value is updated successfully, otherwise false","title":"setMenuItemVariableMin()"},{"location":"api_SFE_QUAD_Menu/#setmenuitemvariablemax","text":"This method sets the maximum permissible value for the menu item variable. This is used by the menu to check the value is in range . bool setMenuItemVariableMax ( const char * itemName , const SFE_QUAD_Menu_Every_Type_t * maxVal ) Parameter Type Description itemName const char * The name of the menu item maxVal const SFE_QUAD_Menu_Every_Type_t * A pointer to the struct holding the maximum value return value bool true if the item exists and the maximum value is updated successfully, otherwise false","title":"setMenuItemVariableMax()"},{"location":"api_SFE_QUAD_Menu/#the-menu","text":"","title":"The Menu"},{"location":"api_SFE_QUAD_Menu/#openmenu","text":"This method opens the menu on the chosen Stream (Serial port). This method calls itself recursively when entering a sub-menu. start points to the address of the SUB_MENU_START menu item. If start is NULL (the default), the menu starts at _head . bool openMenu ( SFE_QUAD_Menu_Item * start ) Parameter Type Description start SFE_QUAD_Menu_Item * The address of the menu item to be shown first return value bool true if the menu item exists and the menu closes normally, otherwise false","title":"openMenu()"},{"location":"api_SFE_QUAD_Menu/#menu-item-variable-storage","text":"","title":"Menu Item Variable Storage"},{"location":"api_SFE_QUAD_Menu/#getnummenuvariables","text":"The method returns the number of menu item variables which should be written to storage. The return value dictates how many time getMenuVariableAsCSV is called. uint16_t getNumMenuVariables ( void ) Parameter Type Description return value uint16_t The number of menu item variables requiring storage","title":"getNumMenuVariables()"},{"location":"api_SFE_QUAD_Menu/#getmenuvariableascsv","text":"This method reads the menu item variable with index num and writes its name, type and value into var as CSV-format text. Higher methods then write that CSV text to storage. maxLen defines how many characters var can hold. The text is not written if var is too small. bool getMenuVariableAsCSV ( uint16_t num , char * var , size_t maxLen ) Parameter Type Description num uint16_t The menu item index var char * A pointer to a char array that the CSV text will be written to maxLen size_t The maximum number of characters var can hold return value bool true if the item exists and is copied successfully, otherwise false","title":"getMenuVariableAsCSV()"},{"location":"api_SFE_QUAD_Menu/#updatemenuvariablefromcsv","text":"line contains a menu variable in CSV format which has been read from storage. This method updates the appropriate menu item variable with the value contained in the CSV text. bool updateMenuVariableFromCSV ( char * line ) Parameter Type Description line char * A pointer to a char array that contains the CSV return value bool true if the menu item exists and is updated successfully, otherwise false","title":"updateMenuVariableFromCSV()"},{"location":"api_SFE_QUAD_Menu/#helper-methods","text":"","title":"Helper Methods"},{"location":"api_SFE_QUAD_Menu/#getmenuchoice","text":"Ask the user to select a menu item. uint32_t getMenuChoice ( unsigned long timeout ) Parameter Type Description timeout unsigned long The timeout in milliseconds return value uint32_t The menu item selected, 0 if none or if a timeout occurred","title":"getMenuChoice()"},{"location":"api_SFE_QUAD_Menu/#getvaluedouble","text":"Ask the user to enter an integer or floating point value. Exponent-format values are also acceptable. bool getValueDouble ( double * value , unsigned long timeout ) Parameter Type Description timeout unsigned long The timeout in milliseconds value double * A pointer to the double which will hold the value return value uint32_t false if nothing is entered or a timeout occurred, otherwise true","title":"getValueDouble()"},{"location":"api_SFE_QUAD_Menu/#getvaluetext","text":"Ask the user to enter a TEXT entry, such as a WiFi password. getValueText will automatically create a new char array to hold the text and returns a pointer to it. The old char array is automatically deleted (freed). bool getValueText ( char ** value , unsigned long timeout ) Parameter Type Description timeout unsigned long The timeout in milliseconds value char * * A pointer to a pointer to the dynamic char array that holds the text return value uint32_t true if text is entered within the timeout, otherwise false","title":"getValueText()"},{"location":"api_SFE_QUAD_Menu/#getmenuitemnamemaxlen","text":"Returns the maximum length of all of the menu item names. Used to format the menus correctly (space padding). size_t getMenuItemNameMaxLen ( void ) Parameter Type Description return value size_t The maximum name length","title":"getMenuItemNameMaxLen()"},{"location":"api_SFE_QUAD_Menu/#getmenuvariablesmaxlen","text":"Returns the likely maximum combined length of a full menu item (including min and max values if present). This is used to determine how much memory should be allocated to hold a menu item in CSV format. size_t getMenuVariablesMaxLen ( void ) Parameter Type Description return value size_t The likely maximum length","title":"getMenuVariablesMaxLen()"},{"location":"api_SFE_QUAD_Menu/#menuitemexists","text":"Returns a pointer to the menu item if it exists, otherwise returns NULL . SFE_QUAD_Menu_Item * menuItemExists ( const char * itemName ) Parameter Type Description itemName const char * The item name return value SFE_QUAD_Menu_Item * A pointer to the menu item (if it exists), otherwise NULL","title":"menuItemExists()"},{"location":"api_SFE_QUAD_Menu/#setmenutimeout","text":"This method sets the menu timeout. void setMenuTimeout ( unsigned long newTimeout ) Parameter Type Description newTimeout unsigned long The new menu timeout in milliseconds","title":"setMenuTimeout()"},{"location":"api_SFE_QUAD_Menu/#setmaxtextchars","text":"This method sets the maximum number of characters that can be entered into a TEXT value. void setMaxTextChars ( uint16_t newMax ) Parameter Type Description newMax uint16_t The new maximum length","title":"setMaxTextChars()"},{"location":"api_SFE_QUAD_Menu/#setsupportsbackspace","text":"This method defines if the _menuPort supports backspace for TEXT entry. void setSupportsBackspace ( bool support ) Parameter Type Description support bool true in the port supports backspace, otherwise false","title":"setSupportsBackspace()"},{"location":"api_SFE_QUAD_Menu/#member-variables","text":"Parameter Type Description _head SFE_QUAD_Menu_Item * A pointer to the first menu item in the linked-list, initially NULL _menuPort Stream * The address of the Stream (Serial port) to be used by the menu _debugPort Stream * The address of the Stream (Serial port) to be used for debug messages (if desired) _menuTimeout unsigned long The default menu timeout in milliseconds. Default is 10000 _maxTextChars uint16_t The maximum length of TEXT value entries. Default is 32 _supportsBackspace bool true if the port supports backspace, otherwise false . Default is false","title":"Member Variables"},{"location":"api_SFE_QUAD_Menu_Item/","text":"API Reference for the SFE_QUAD_Menu_Item class Brief Overview The SFE_QUAD_Menu class allows the user to create a menu as a linked-list of SFE_QUAD_Menu_Item objects. The SFE_QUAD_Menu _head points to the head (start) of the linked list. The _next of the final SFE_QUAD_Menu_Item in the list is NULL . If the menu item is a variable (BOOL, INT, etc.), the value is stored in a SFE_QUAD_Menu_Every_Type_t pointed to by _theVariable . _theVariable is NULL initially. The SFE_QUAD_Menu_Every_Type_t object is instantiated if needed and its address is stored in _theVariable . This avoids wasting memory. Helper Methods const char *getMenuItemName(void) Returns a pointer to the _itemName of the menu item so it can be printed etc.. const char * getMenuItemName ( void ) Parameter Type Description return value const char * A pointer to the _itemName of the menu item deleteMenuItemStorage() This method is responsible for deleting (freeing) all dynamic memory used by the SFE_QUAD_Menu_Item object. It is called by the destructor. void deleteMenuItemStorage ( void ) Member Variables Parameter Type Description _next SFE_QUAD_Menu_Item * A pointer to the next menu item in the linked-list _itemName char * A pointer to a dynamic char array which holds the menu item name (ASCII text, null-terminated) _variableType SFE_QUAD_Menu_Variable_Type_e The menu item type (NONE, CODE, TEXT, BOOL, INT, etc.) _theVariable SFE_QUAD_Menu_Every_Type_t * A pointer to a SFE_QUAD_Menu_Every_Type_t which will hold the menu item variable (if needed) _minVal SFE_QUAD_Menu_Every_Type_t * A pointer to a SFE_QUAD_Menu_Every_Type_t which will hold the minimum value for the menu item (if needed) _maxVal SFE_QUAD_Menu_Every_Type_t * A pointer to a SFE_QUAD_Menu_Every_Type_t which will hold the maximum value for the menu item (if needed)","title":"SFE_QUAD_Menu_Item"},{"location":"api_SFE_QUAD_Menu_Item/#api-reference-for-the-sfe_quad_menu_item-class","text":"","title":"API Reference for the SFE_QUAD_Menu_Item class"},{"location":"api_SFE_QUAD_Menu_Item/#brief-overview","text":"The SFE_QUAD_Menu class allows the user to create a menu as a linked-list of SFE_QUAD_Menu_Item objects. The SFE_QUAD_Menu _head points to the head (start) of the linked list. The _next of the final SFE_QUAD_Menu_Item in the list is NULL . If the menu item is a variable (BOOL, INT, etc.), the value is stored in a SFE_QUAD_Menu_Every_Type_t pointed to by _theVariable . _theVariable is NULL initially. The SFE_QUAD_Menu_Every_Type_t object is instantiated if needed and its address is stored in _theVariable . This avoids wasting memory.","title":"Brief Overview"},{"location":"api_SFE_QUAD_Menu_Item/#helper-methods","text":"","title":"Helper Methods"},{"location":"api_SFE_QUAD_Menu_Item/#const-char-getmenuitemnamevoid","text":"Returns a pointer to the _itemName of the menu item so it can be printed etc.. const char * getMenuItemName ( void ) Parameter Type Description return value const char * A pointer to the _itemName of the menu item","title":"const char *getMenuItemName(void)"},{"location":"api_SFE_QUAD_Menu_Item/#deletemenuitemstorage","text":"This method is responsible for deleting (freeing) all dynamic memory used by the SFE_QUAD_Menu_Item object. It is called by the destructor. void deleteMenuItemStorage ( void )","title":"deleteMenuItemStorage()"},{"location":"api_SFE_QUAD_Menu_Item/#member-variables","text":"Parameter Type Description _next SFE_QUAD_Menu_Item * A pointer to the next menu item in the linked-list _itemName char * A pointer to a dynamic char array which holds the menu item name (ASCII text, null-terminated) _variableType SFE_QUAD_Menu_Variable_Type_e The menu item type (NONE, CODE, TEXT, BOOL, INT, etc.) _theVariable SFE_QUAD_Menu_Every_Type_t * A pointer to a SFE_QUAD_Menu_Every_Type_t which will hold the menu item variable (if needed) _minVal SFE_QUAD_Menu_Every_Type_t * A pointer to a SFE_QUAD_Menu_Every_Type_t which will hold the minimum value for the menu item (if needed) _maxVal SFE_QUAD_Menu_Every_Type_t * A pointer to a SFE_QUAD_Menu_Every_Type_t which will hold the maximum value for the menu item (if needed)","title":"Member Variables"},{"location":"api_SFE_QUAD_Menu_sprintf/","text":"API Reference for the SFE_QUAD_Menu_sprintf class Helper methods to support printing of double variables. Helper Methods printDouble() Print a double (included because not all platforms support dtostrf or sprintf correctly). void printDouble ( double value , Print * pr ) Parameter Type Description value double The double to be printed pr Print * The Stream , File etc. that the double will be printed to _dtostrf() Convert double to string (included because not all platforms support dtostrf correctly). It is the calling method's responsibility to ensure buffer is large enough to contain the complete string. char * _dtostrf ( double value , char * buffer ) Parameter Type Description value double The double to be converted to string buffer char * A pointer to a char array to hold the text return value char * A pointer to the char after the final one printed setPrecision() Set the precision (number of decimal places) to be used by _dtostrf and printDouble . void setPrecision ( unsigned char prec ) Parameter Type Description prec unsigned char The precision getPrecision() Returns the current precision. unsigned char getPrecision ( void ) Parameter Type Description return value unsigned char The precision Member Variables Parameter Type Description _prec unsigned char The precision (number of decimal places) to be printed","title":"SFE_QUAD_Menu_sprintf"},{"location":"api_SFE_QUAD_Menu_sprintf/#api-reference-for-the-sfe_quad_menu_sprintf-class","text":"Helper methods to support printing of double variables.","title":"API Reference for the SFE_QUAD_Menu_sprintf class"},{"location":"api_SFE_QUAD_Menu_sprintf/#helper-methods","text":"","title":"Helper Methods"},{"location":"api_SFE_QUAD_Menu_sprintf/#printdouble","text":"Print a double (included because not all platforms support dtostrf or sprintf correctly). void printDouble ( double value , Print * pr ) Parameter Type Description value double The double to be printed pr Print * The Stream , File etc. that the double will be printed to","title":"printDouble()"},{"location":"api_SFE_QUAD_Menu_sprintf/#_dtostrf","text":"Convert double to string (included because not all platforms support dtostrf correctly). It is the calling method's responsibility to ensure buffer is large enough to contain the complete string. char * _dtostrf ( double value , char * buffer ) Parameter Type Description value double The double to be converted to string buffer char * A pointer to a char array to hold the text return value char * A pointer to the char after the final one printed","title":"_dtostrf()"},{"location":"api_SFE_QUAD_Menu_sprintf/#setprecision","text":"Set the precision (number of decimal places) to be used by _dtostrf and printDouble . void setPrecision ( unsigned char prec ) Parameter Type Description prec unsigned char The precision","title":"setPrecision()"},{"location":"api_SFE_QUAD_Menu_sprintf/#getprecision","text":"Returns the current precision. unsigned char getPrecision ( void ) Parameter Type Description return value unsigned char The precision","title":"getPrecision()"},{"location":"api_SFE_QUAD_Menu_sprintf/#member-variables","text":"Parameter Type Description _prec unsigned char The precision (number of decimal places) to be printed","title":"Member Variables"},{"location":"api_SFE_QUAD_Sensor/","text":"API Reference for the SFE_QUAD_Sensor class Methods to allow the sensor's underlying Arduino Library be accessed in a homogeneous way: Return the sensor's name Return which I2C addresses are valid for this sensor Detect the sensor Begin the sensor (usually by calling the underlying library's begin method) Initialize the sensor (if required) Set a pointer to custom initialization code for this sensor Return the number of senses this sensor has Return the names of the senses Return the maximum length of the sense names (to aid menu formatting) Return a sense reading Return a count of the number of settings this sensor has (if any) Return the names of the settings Return the maximum length of the settings names (to aid menu formatting) Return the setting type Set a setting Return a count of the number of things which can be configured on this sensor Return the names of the things which can be configured on this sensor Return the maximum length of the configuration item names Return the configuration item type Return the configuration item Set the configuration item Brief Overview The SFE_QUAD_Sensor class allows that sensor's Arduino Library to be accessed in a homogeneous way. It provides common methods for all sensor types, to allow SFE_QUAD_Sensors to read and configure the sensor without needing to know the underlying library's methods. Think of SFE_QUAD_Sensor as a thin layer which sits on top of the Arduino Library and which provides common access methods for it. A sensor can have multiple senses . E.g. the BME280 has three : pressure, temperature and humidity. A sensor may have several things which can be set. These are the settings . E.g. the NAU7802 scale has two : zero offset ( calculateZeroOffset ) and calibration factor ( calculateCalibrationFactor ). Configuration items are settings which are written to and read from storage (SD, EEPROM, LittleFS). They are used to record the sensor configuration and restore the configuration. Note: the configuration items may or may not be the same as the settings. Individual SFE_QUAD_Sensor instances are connected in a linked-list. The SFE_QUAD_Sensor object contains a pointer to the _next object in the list. The _next of the final SFE_QUAD_Sensor in the list is NULL . The SFE_QUAD_Sensors object is responsible for creating the linked-list. The possible (known) sensor types are defined in the enum SFEQUADSensorType in the SFE_QUAD_Sensors class. Sensor detection and initialization will typically be performed as follows: For each sensor type in enum SFEQUADSensorType : If any Qwiic Muxes are detected, sensor detection is performed on all ports of all muxes. The possible I2C addresses for the sensor are requested using getNumI2cAddresses and getI2cAddress . The sensor is detected using detectSensor . This usually calls the sensor's begin method, but not always. If the sensor is detected, it is added to the linked-list of SFE_QUAD_Sensor objects. Its I2C address is recorded. If it is connected through a Mux, the Mux address and port are recorded. Once detection is complete, each sensor is initialized using initializeSensor . If a custom initializer has been defined, that is used in place of the standard initializer. Reading the senses will typically be performed as follows: For each sensor in the linked-list: getSenseCount returns the number of senses this sensor has _logSense (an array of bool ) records if each individual sense is enabled for logging All enabled senses are read using getSenseReading The sense names can be read using getSenseName . getSenseNameMaxLen aids menu formatting (space padding). The class destructor ensures that all memory used by the linked-list is deleted (freed) correctly. This has been fully tested - see Example5 for details. Most SFE_QUAD_Sensor methods are virtual as they need to be redefined by the methods of the individual sensors. The individual sensor classes (e.g. SFE_QUAD_Sensor_ADS122C04 ) are derived. They inherit SFE_QUAD_Sensor and then redefine each method with their own. Initialization / Configuration getSensorName() This method returns a pointer to the sensor's name. virtual const char * getSensorName ( void ) Parameter Type Description return value const char * A pointer to the sensor's name (ASCII text, null-terminated) getNumI2cAddresses() This method returns the number of I2C addresses this sensor supports. virtual uint8_t getNumI2cAddresses ( void ) Parameter Type Description return value uint8_t The number of addresses getI2cAddress() This method returns the I2C address for the index address . virtual uint8_t getI2cAddress ( uint8_t address ) Parameter Type Description address uint8_t The address index return value uint8_t The I2C address detectSensor() This method attempts to detect the sensor at address sensorAddress using Wire port port . This method usually , but not always, calls the Arduino Library's begin method. virtual bool detectSensor ( uint8_t sensorAddress , TwoWire & port ) Parameter Type Description sensorAddress uint8_t The sensor's I2C address (may be required by begin ) port TwoWire & The Wire port the sensor is connected to (may be required by begin ) return value bool true if the sensor is detected, false otherwise beginSensor() This method calls the sensor's Arduino Library begin method. virtual bool beginSensor ( uint8_t sensorAddress , TwoWire & port ) Parameter Type Description sensorAddress uint8_t The sensor's I2C address (may be required by begin ) port TwoWire & The Wire port the sensor is connected to (may be required by begin ) return value bool true if the sensor is begun successfully, false otherwise initializeSensor() Perform any initialization methods this sensor requires. If a custom initializer has been defined, perform that instead. virtual bool initializeSensor ( uint8_t sensorAddress , TwoWire & port ) Parameter Type Description sensorAddress uint8_t The sensor's I2C address port TwoWire & The Wire port the sensor is connected to return value bool true if the sensor is initialized successfully, false otherwise setCustomInitializePtr() Set a pointer to the custom initializer for this sensor. void setCustomInitializePtr ( void ( * pointer )( uint8_t sensorAddress , TwoWire & port , void * _classPtr )) Parameter Type Description pointer void (*)() The address of the custom initializer The parameters for the custom initializer method are: Parameter Type Description sensorAddress uint8_t The sensor's I2C address (may be required) port TwoWire & The Wire port the sensor is connected to (may be required) _classPtr void * A pointer to the Arduino Library class instance for this sensor (required to access the class methods) getSenseCount() Return the number of senses this sensor has. virtual bool getSenseCount ( uint8_t * count ) Parameter Type Description count uint8_t Pointer to the uint8_t which will hold the count return value bool true if the sensor exists, false otherwise getSenseName() This method returns a pointer to the name of the sense with index sense . virtual const char * getSenseName ( uint8_t sense ) Parameter Type Description sense uint8_t The sense index return value const char * A pointer to the sense's name (ASCII text, null-terminated) getSenseNameMaxLen() Return the maximum length of all sense names for this sensor. Useful for menu formatting (space padding). virtual uint8_t getSenseNameMaxLen () Parameter Type Description return value uint8_t The maximum name length getSenseReading() Read the sense with index sense . Return the reading as ASCII text in the char array reading . The calling method is responsible for ensuring reading can hold the entire reading. virtual bool getSenseReading ( uint8_t sense , char * reading ) Parameter Type Description sense uint8_t The sense index reading char * A pointer to a char array to hold the reading (ASCII text, null-terminated) return value bool true is the read is successful, false otherwise getSettingCount() Return the count of the number of settings this sensor has. virtual bool getSettingCount ( uint8_t * count ) Parameter Type Description count uint8_t Pointer to the uint8_t which will hold the count return value bool true if the sensor exists, false otherwise getSettingName() This method returns a pointer to the name of the setting with index sense . virtual const char * getSettingName ( uint8_t sense ) Parameter Type Description sense uint8_t The setting index return value const char * A pointer to the setting name (ASCII text, null-terminated) getSettingNameMaxLen() Return the maximum length of all settings names for this sensor. Useful for menu formatting (space padding). virtual uint8_t getSettingNameMaxLen () Parameter Type Description return value uint8_t The maximum name length getSettingType() Return the setting type ( SFE_QUAD_Sensor_Setting_Type_e ) (BOOL, FLOAT, INT, etc.) for this setting. virtual bool getSettingType ( uint8_t setting , SFE_QUAD_Sensor_Setting_Type_e * type ) Parameter Type Description setting uint8_t The setting index type SFE_QUAD_Sensor_Setting_Type_e * Pointer to the enum which will hold the setting type return value bool true if the sensor exists, otherwise false setSetting() Apply the value in value to the sensor setting with index setting . virtual bool setSetting ( uint8_t setting , SFE_QUAD_Sensor_Every_Type_t * value ) Parameter Type Description setting uint8_t The setting index value SFE_QUAD_Sensor_Setting_Every_Type_t * Pointer to the struct containing the setting return value bool true if successful, otherwise false getConfigurationItemCount() Return the count of the number of configuration items this sensor has. Configuration items are settings which need to be written to and read from storage media. virtual bool getConfigurationItemCount ( uint8_t * count ) Parameter Type Description count uint8_t Pointer to the uint8_t which will hold the count return value bool true if the sensor exists, false otherwise getConfigurationItemName() This method returns a pointer to the name of the configuration item with index configItem . virtual const char * getConfigurationItemName ( uint8_t configItem ) Parameter Type Description configItem uint8_t The configuration item index return value const char * A pointer to the configuration item name (ASCII text, null-terminated) getConfigurationItemNameMaxLen() Return the maximum length of all configuration item names for this sensor. Useful for menu formatting (space padding). virtual uint8_t getConfigurationItemNameMaxLen () Parameter Type Description return value uint8_t The maximum name length getConfigurationItemType() Return the type ( SFE_QUAD_Sensor_Setting_Type_e ) (BOOL, FLOAT, INT, etc.) for this configuration item. virtual bool getConfigurationItemType ( uint8_t configItem , SFE_QUAD_Sensor_Setting_Type_e * type ) Parameter Type Description configItem uint8_t The configuration item index type SFE_QUAD_Sensor_Setting_Type_e * Pointer to the enum which will hold the configuration type return value bool true if the sensor exists, otherwise false getConfigurationItem() Read the sensor configuration item with index configItem and store it in value . virtual bool getConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) Parameter Type Description configItem uint8_t The configuration item index value SFE_QUAD_Sensor_Setting_Every_Type_t * Pointer to the struct which will hold the value return value bool true if successful, otherwise false setConfigurationItem() Apply the value in value to the sensor configuration item with index configItem . virtual bool setConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) Parameter Type Description configItem uint8_t The configuration item index value SFE_QUAD_Sensor_Setting_Every_Type_t * Pointer to the struct containing the value return value bool true if successful, otherwise false Helper Methods deleteSensorStorage() This method is responsible for deleting (freeing) all dynamic memory used by the SFE_QUAD_Sensor object. It is called by the destructor. virtual void deleteSensorStorage ( void ) Member Variables Parameter Type Description _sensorAddress uint8_t The I2C address of this sensor _muxAddress uint8_t The I2C address of the mux this sensor is connected to, 0 is none _muxPort uint8_t The mux port number this sensor is connected to, 0 if none _classPtr void * A pointer to the Arduino Library class instance for this sensor _next SFE_QUAD_Sensor * A pointer to the next sensor in the linked-list _logSense bool * A dynamic array of bool indicating if individual senses are enabled for logging _customInitializePtr void (*)() A pointer to the custom initializer for this sensor, NULL if none _sprintf SFE_QUAD_Sensors_sprintf An instance of SFE_QUAD_Sensors_sprintf to aid printing of double and exponent data Data Types SFE_QUAD_Sensor_Every_Type_t As the name suggests, this structure contains one of every data type used by the underlying Arduino Libraries. It allows values to be passed between classes in a homogeneous, non-type-specific way. The data type is defined by the associated SFE_QUAD_Sensor_Setting_Type_e enum. typedef struct { bool BOOL ; float FLOAT ; double DOUBLE ; int INT ; uint8_t UINT8_T ; uint16_t UINT16_T ; uint32_t UINT32_T ; } SFE_QUAD_Sensor_Every_Type_t ; Member Type Description BOOL bool A bool FLOAT float A float DOUBLE double A double INT int An int UINT8_T uint8_t A uint8_t UINT16_T uint16_t A uint16_t UINT32_T uint32_t A uint32_t","title":"SFE_QUAD_Sensor"},{"location":"api_SFE_QUAD_Sensor/#api-reference-for-the-sfe_quad_sensor-class","text":"Methods to allow the sensor's underlying Arduino Library be accessed in a homogeneous way: Return the sensor's name Return which I2C addresses are valid for this sensor Detect the sensor Begin the sensor (usually by calling the underlying library's begin method) Initialize the sensor (if required) Set a pointer to custom initialization code for this sensor Return the number of senses this sensor has Return the names of the senses Return the maximum length of the sense names (to aid menu formatting) Return a sense reading Return a count of the number of settings this sensor has (if any) Return the names of the settings Return the maximum length of the settings names (to aid menu formatting) Return the setting type Set a setting Return a count of the number of things which can be configured on this sensor Return the names of the things which can be configured on this sensor Return the maximum length of the configuration item names Return the configuration item type Return the configuration item Set the configuration item","title":"API Reference for the SFE_QUAD_Sensor class"},{"location":"api_SFE_QUAD_Sensor/#brief-overview","text":"The SFE_QUAD_Sensor class allows that sensor's Arduino Library to be accessed in a homogeneous way. It provides common methods for all sensor types, to allow SFE_QUAD_Sensors to read and configure the sensor without needing to know the underlying library's methods. Think of SFE_QUAD_Sensor as a thin layer which sits on top of the Arduino Library and which provides common access methods for it. A sensor can have multiple senses . E.g. the BME280 has three : pressure, temperature and humidity. A sensor may have several things which can be set. These are the settings . E.g. the NAU7802 scale has two : zero offset ( calculateZeroOffset ) and calibration factor ( calculateCalibrationFactor ). Configuration items are settings which are written to and read from storage (SD, EEPROM, LittleFS). They are used to record the sensor configuration and restore the configuration. Note: the configuration items may or may not be the same as the settings. Individual SFE_QUAD_Sensor instances are connected in a linked-list. The SFE_QUAD_Sensor object contains a pointer to the _next object in the list. The _next of the final SFE_QUAD_Sensor in the list is NULL . The SFE_QUAD_Sensors object is responsible for creating the linked-list. The possible (known) sensor types are defined in the enum SFEQUADSensorType in the SFE_QUAD_Sensors class. Sensor detection and initialization will typically be performed as follows: For each sensor type in enum SFEQUADSensorType : If any Qwiic Muxes are detected, sensor detection is performed on all ports of all muxes. The possible I2C addresses for the sensor are requested using getNumI2cAddresses and getI2cAddress . The sensor is detected using detectSensor . This usually calls the sensor's begin method, but not always. If the sensor is detected, it is added to the linked-list of SFE_QUAD_Sensor objects. Its I2C address is recorded. If it is connected through a Mux, the Mux address and port are recorded. Once detection is complete, each sensor is initialized using initializeSensor . If a custom initializer has been defined, that is used in place of the standard initializer. Reading the senses will typically be performed as follows: For each sensor in the linked-list: getSenseCount returns the number of senses this sensor has _logSense (an array of bool ) records if each individual sense is enabled for logging All enabled senses are read using getSenseReading The sense names can be read using getSenseName . getSenseNameMaxLen aids menu formatting (space padding). The class destructor ensures that all memory used by the linked-list is deleted (freed) correctly. This has been fully tested - see Example5 for details. Most SFE_QUAD_Sensor methods are virtual as they need to be redefined by the methods of the individual sensors. The individual sensor classes (e.g. SFE_QUAD_Sensor_ADS122C04 ) are derived. They inherit SFE_QUAD_Sensor and then redefine each method with their own.","title":"Brief Overview"},{"location":"api_SFE_QUAD_Sensor/#initialization-configuration","text":"","title":"Initialization / Configuration"},{"location":"api_SFE_QUAD_Sensor/#getsensorname","text":"This method returns a pointer to the sensor's name. virtual const char * getSensorName ( void ) Parameter Type Description return value const char * A pointer to the sensor's name (ASCII text, null-terminated)","title":"getSensorName()"},{"location":"api_SFE_QUAD_Sensor/#getnumi2caddresses","text":"This method returns the number of I2C addresses this sensor supports. virtual uint8_t getNumI2cAddresses ( void ) Parameter Type Description return value uint8_t The number of addresses","title":"getNumI2cAddresses()"},{"location":"api_SFE_QUAD_Sensor/#geti2caddress","text":"This method returns the I2C address for the index address . virtual uint8_t getI2cAddress ( uint8_t address ) Parameter Type Description address uint8_t The address index return value uint8_t The I2C address","title":"getI2cAddress()"},{"location":"api_SFE_QUAD_Sensor/#detectsensor","text":"This method attempts to detect the sensor at address sensorAddress using Wire port port . This method usually , but not always, calls the Arduino Library's begin method. virtual bool detectSensor ( uint8_t sensorAddress , TwoWire & port ) Parameter Type Description sensorAddress uint8_t The sensor's I2C address (may be required by begin ) port TwoWire & The Wire port the sensor is connected to (may be required by begin ) return value bool true if the sensor is detected, false otherwise","title":"detectSensor()"},{"location":"api_SFE_QUAD_Sensor/#beginsensor","text":"This method calls the sensor's Arduino Library begin method. virtual bool beginSensor ( uint8_t sensorAddress , TwoWire & port ) Parameter Type Description sensorAddress uint8_t The sensor's I2C address (may be required by begin ) port TwoWire & The Wire port the sensor is connected to (may be required by begin ) return value bool true if the sensor is begun successfully, false otherwise","title":"beginSensor()"},{"location":"api_SFE_QUAD_Sensor/#initializesensor","text":"Perform any initialization methods this sensor requires. If a custom initializer has been defined, perform that instead. virtual bool initializeSensor ( uint8_t sensorAddress , TwoWire & port ) Parameter Type Description sensorAddress uint8_t The sensor's I2C address port TwoWire & The Wire port the sensor is connected to return value bool true if the sensor is initialized successfully, false otherwise","title":"initializeSensor()"},{"location":"api_SFE_QUAD_Sensor/#setcustominitializeptr","text":"Set a pointer to the custom initializer for this sensor. void setCustomInitializePtr ( void ( * pointer )( uint8_t sensorAddress , TwoWire & port , void * _classPtr )) Parameter Type Description pointer void (*)() The address of the custom initializer The parameters for the custom initializer method are: Parameter Type Description sensorAddress uint8_t The sensor's I2C address (may be required) port TwoWire & The Wire port the sensor is connected to (may be required) _classPtr void * A pointer to the Arduino Library class instance for this sensor (required to access the class methods)","title":"setCustomInitializePtr()"},{"location":"api_SFE_QUAD_Sensor/#getsensecount","text":"Return the number of senses this sensor has. virtual bool getSenseCount ( uint8_t * count ) Parameter Type Description count uint8_t Pointer to the uint8_t which will hold the count return value bool true if the sensor exists, false otherwise","title":"getSenseCount()"},{"location":"api_SFE_QUAD_Sensor/#getsensename","text":"This method returns a pointer to the name of the sense with index sense . virtual const char * getSenseName ( uint8_t sense ) Parameter Type Description sense uint8_t The sense index return value const char * A pointer to the sense's name (ASCII text, null-terminated)","title":"getSenseName()"},{"location":"api_SFE_QUAD_Sensor/#getsensenamemaxlen","text":"Return the maximum length of all sense names for this sensor. Useful for menu formatting (space padding). virtual uint8_t getSenseNameMaxLen () Parameter Type Description return value uint8_t The maximum name length","title":"getSenseNameMaxLen()"},{"location":"api_SFE_QUAD_Sensor/#getsensereading","text":"Read the sense with index sense . Return the reading as ASCII text in the char array reading . The calling method is responsible for ensuring reading can hold the entire reading. virtual bool getSenseReading ( uint8_t sense , char * reading ) Parameter Type Description sense uint8_t The sense index reading char * A pointer to a char array to hold the reading (ASCII text, null-terminated) return value bool true is the read is successful, false otherwise","title":"getSenseReading()"},{"location":"api_SFE_QUAD_Sensor/#getsettingcount","text":"Return the count of the number of settings this sensor has. virtual bool getSettingCount ( uint8_t * count ) Parameter Type Description count uint8_t Pointer to the uint8_t which will hold the count return value bool true if the sensor exists, false otherwise","title":"getSettingCount()"},{"location":"api_SFE_QUAD_Sensor/#getsettingname","text":"This method returns a pointer to the name of the setting with index sense . virtual const char * getSettingName ( uint8_t sense ) Parameter Type Description sense uint8_t The setting index return value const char * A pointer to the setting name (ASCII text, null-terminated)","title":"getSettingName()"},{"location":"api_SFE_QUAD_Sensor/#getsettingnamemaxlen","text":"Return the maximum length of all settings names for this sensor. Useful for menu formatting (space padding). virtual uint8_t getSettingNameMaxLen () Parameter Type Description return value uint8_t The maximum name length","title":"getSettingNameMaxLen()"},{"location":"api_SFE_QUAD_Sensor/#getsettingtype","text":"Return the setting type ( SFE_QUAD_Sensor_Setting_Type_e ) (BOOL, FLOAT, INT, etc.) for this setting. virtual bool getSettingType ( uint8_t setting , SFE_QUAD_Sensor_Setting_Type_e * type ) Parameter Type Description setting uint8_t The setting index type SFE_QUAD_Sensor_Setting_Type_e * Pointer to the enum which will hold the setting type return value bool true if the sensor exists, otherwise false","title":"getSettingType()"},{"location":"api_SFE_QUAD_Sensor/#setsetting","text":"Apply the value in value to the sensor setting with index setting . virtual bool setSetting ( uint8_t setting , SFE_QUAD_Sensor_Every_Type_t * value ) Parameter Type Description setting uint8_t The setting index value SFE_QUAD_Sensor_Setting_Every_Type_t * Pointer to the struct containing the setting return value bool true if successful, otherwise false","title":"setSetting()"},{"location":"api_SFE_QUAD_Sensor/#getconfigurationitemcount","text":"Return the count of the number of configuration items this sensor has. Configuration items are settings which need to be written to and read from storage media. virtual bool getConfigurationItemCount ( uint8_t * count ) Parameter Type Description count uint8_t Pointer to the uint8_t which will hold the count return value bool true if the sensor exists, false otherwise","title":"getConfigurationItemCount()"},{"location":"api_SFE_QUAD_Sensor/#getconfigurationitemname","text":"This method returns a pointer to the name of the configuration item with index configItem . virtual const char * getConfigurationItemName ( uint8_t configItem ) Parameter Type Description configItem uint8_t The configuration item index return value const char * A pointer to the configuration item name (ASCII text, null-terminated)","title":"getConfigurationItemName()"},{"location":"api_SFE_QUAD_Sensor/#getconfigurationitemnamemaxlen","text":"Return the maximum length of all configuration item names for this sensor. Useful for menu formatting (space padding). virtual uint8_t getConfigurationItemNameMaxLen () Parameter Type Description return value uint8_t The maximum name length","title":"getConfigurationItemNameMaxLen()"},{"location":"api_SFE_QUAD_Sensor/#getconfigurationitemtype","text":"Return the type ( SFE_QUAD_Sensor_Setting_Type_e ) (BOOL, FLOAT, INT, etc.) for this configuration item. virtual bool getConfigurationItemType ( uint8_t configItem , SFE_QUAD_Sensor_Setting_Type_e * type ) Parameter Type Description configItem uint8_t The configuration item index type SFE_QUAD_Sensor_Setting_Type_e * Pointer to the enum which will hold the configuration type return value bool true if the sensor exists, otherwise false","title":"getConfigurationItemType()"},{"location":"api_SFE_QUAD_Sensor/#getconfigurationitem","text":"Read the sensor configuration item with index configItem and store it in value . virtual bool getConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) Parameter Type Description configItem uint8_t The configuration item index value SFE_QUAD_Sensor_Setting_Every_Type_t * Pointer to the struct which will hold the value return value bool true if successful, otherwise false","title":"getConfigurationItem()"},{"location":"api_SFE_QUAD_Sensor/#setconfigurationitem","text":"Apply the value in value to the sensor configuration item with index configItem . virtual bool setConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) Parameter Type Description configItem uint8_t The configuration item index value SFE_QUAD_Sensor_Setting_Every_Type_t * Pointer to the struct containing the value return value bool true if successful, otherwise false","title":"setConfigurationItem()"},{"location":"api_SFE_QUAD_Sensor/#helper-methods","text":"","title":"Helper Methods"},{"location":"api_SFE_QUAD_Sensor/#deletesensorstorage","text":"This method is responsible for deleting (freeing) all dynamic memory used by the SFE_QUAD_Sensor object. It is called by the destructor. virtual void deleteSensorStorage ( void )","title":"deleteSensorStorage()"},{"location":"api_SFE_QUAD_Sensor/#member-variables","text":"Parameter Type Description _sensorAddress uint8_t The I2C address of this sensor _muxAddress uint8_t The I2C address of the mux this sensor is connected to, 0 is none _muxPort uint8_t The mux port number this sensor is connected to, 0 if none _classPtr void * A pointer to the Arduino Library class instance for this sensor _next SFE_QUAD_Sensor * A pointer to the next sensor in the linked-list _logSense bool * A dynamic array of bool indicating if individual senses are enabled for logging _customInitializePtr void (*)() A pointer to the custom initializer for this sensor, NULL if none _sprintf SFE_QUAD_Sensors_sprintf An instance of SFE_QUAD_Sensors_sprintf to aid printing of double and exponent data","title":"Member Variables"},{"location":"api_SFE_QUAD_Sensor/#data-types","text":"","title":"Data Types"},{"location":"api_SFE_QUAD_Sensor/#sfe_quad_sensor_every_type_t","text":"As the name suggests, this structure contains one of every data type used by the underlying Arduino Libraries. It allows values to be passed between classes in a homogeneous, non-type-specific way. The data type is defined by the associated SFE_QUAD_Sensor_Setting_Type_e enum. typedef struct { bool BOOL ; float FLOAT ; double DOUBLE ; int INT ; uint8_t UINT8_T ; uint16_t UINT16_T ; uint32_t UINT32_T ; } SFE_QUAD_Sensor_Every_Type_t ; Member Type Description BOOL bool A bool FLOAT float A float DOUBLE double A double INT int An int UINT8_T uint8_t A uint8_t UINT16_T uint16_t A uint16_t UINT32_T uint32_t A uint32_t","title":"SFE_QUAD_Sensor_Every_Type_t"},{"location":"api_SFE_QUAD_Sensors/","text":"API Reference for the SFE_QUAD_Sensors class Methods to setup, configure and query the SFE_QUAD_Sensor object: Return a pointer to the specified sensor class so it can be added to the linked-list of sensors Define which Wire port will be used Define which Serial port will be used for the built-in menus Detect which sensors are attached Begin those sensors Initialize those sensors (if required) Get the sense readings from all enabled sensors Get the names of all enabled sensors Get the names of all enabled senses Define a custom initializer for a sensor (if required / desired) Determine if a sensor exists Open the logging menu Open the setting menu Get the sensor and menu configuration in text format Apply configuration settings to the sensors and menus Brief Overview The SFE_QUAD_Sensors class allows a linked-list of individual SFE_QUAD_Sensor objects to be generated and maintained. A SFE_QUAD_Sensors object contains a pointer to a SFE_QUAD_Sensor named _head . _head the the head (start) of a linked-list of SFE_QUAD_Sensor objects. _head is NULL initially. After calling detectSensors , it contains the address of the first SFE_QUAD_Sensor in the linked-list. Each SFE_QUAD_Sensor contains a pointer named _next which points to the next SFE_QUAD_Sensor in the linked-list. The _next of the final SFE_QUAD_Sensor in the list is NULL . The possible (known) sensor types are defined in the enum SFEQUADSensorType . detectSensors discovers which individual sensors are attached on the selected Wire port and adds them to the linked-list. detectSensors has built-in Qwiic Mux support and will discover all muxes, and all sensors connected to the ports on those muxes. beginSensors will call the .begin method of each attached sensor in turn. initializeSensors will perform any additional initialization (if any) required by those sensors. It is possible to override the initialization code for each sensor type, or individual sensor objects, by calling setCustomInitialize . (You must call setCustomInitialize before initialzeSensors .) loggingMenu and settingMenu are methods which open built-in menus to: Configure which senses on each sensor are enabled for logging Call any settings methods the sensors may have (if any) The sense readings are stored in a dynamic char array named readings . The enabled senses are read with getSensorReadings . Memory for readings is allocated dynamically (using new ). The memory is freed automatically by the class destructor. The class has been checked for memory leaks - see Example5. The names of all enabled sensors, together with their I2C and Mux addresses (if any), can be read with getSensorNames . The names are returned in readings . The names of all enabled senses can be read with getSenseNames . The names are returned in readings . The sensor and menu configuration can be stored temporarily in a dynamic char array named configuration . The text CSV configuration is written to storage and read from storage by the individual classes for EEPROM, LittleFS, SD and SdFat: SFE_QUAD_Sensors__EEPROM SFE_QUAD_Sensors__LittleFS SFE_QUAD_Sensors__SD SFE_QUAD_Sensors__SdFat Those classes provide additional methods named writeConfigurationToStorage , readConfigurationFromStorage etc. which write and read configuration to and from the appropriate storage medium. Initialization / Configuration setWirePort() This method is called to set the I2C Wire ( TwoWire ) port to which the sensors are connected. void setWirePort ( TwoWire & port ) Parameter Type Description port TwoWire & The Wire port enableDebugging() This method is called to enable debugging messages on the chosen Stream (usually a Serial port). void enableDebugging ( Stream & port ) Parameter Type Description port Stream & The Stream (Serial port) There is no method to disable the debug messages. The messages can be disabled by setting _printDebug to false: mySensors . _printDebug = false ; This method also enables debug messages on the theMenu object. The menu debug messages can be changed / disabled with the theMenu.setDebugPort method. setMenuPort() This method sets the Stream (usually a Serial port) for the built-in menus. void setMenuPort ( Stream & port ) Parameter Type Description port Stream & The Stream (Serial port) Sensor Factory sensorFactory() This method is used internally by the detectSensors method. It returns a pointer to a new instance of a SFE_QUAD_Sensor for the selected type. SFE_QUAD_Sensor * sensorFactory ( SFEQUADSensorType type ) Parameter Type Description type SFEQUADSensorType The enumerated type of the sensor return value SFE_QUAD_Sensor * A pointer to the new sensor instance Sensor Detection / Initialization detectSensors() This method discovers which individual sensors are attached on the selected Wire port. It has built-in Qwiic Mux support and will discover all muxes, and all sensors connected to the ports on those muxes. The detected sensors are stored internally as a linked-list, pointed to by _head . bool detectSensors ( void ) Parameter Type Description return value bool false if the Wire port is not defined or a memory-allocation error occurred, otherwise true beginSensors() This method begins all detected sensors using each sensor's individual .begin method. bool beginSensors ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true initializeSensors() This method initializes any detected sensors if required: only if the library contains initialization code for that sensor type and/or a custom initializer has been defined for that individual sensor or sensor type bool initializeSensors ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true setCustomInitialize() This method defines custom initialization code for all instances of sensorName . bool setCustomInitialize ( void ( * pointer )( uint8_t sensorAddress , TwoWire & port , void * _classPtr ), const char * sensorName ) Parameter Type Description pointer void (*)() The address of the custom initialization method sensorName const char * The name of the sensor type return value bool false if no sensors have been detected, otherwise true The parameters for the custom initializer method are: Parameter Type Description sensorAddress uint8_t The I2C address of this sensor port TwoWire & The Wire port this sensor is connected to _classPtr void * A pointer to the class for this sensor type return value bool false if no sensors have been detected, otherwise true Please see Example4_CustomInitialization for more details. setCustomInitialize() This method defines custom initialization code for the instance of sensorName at the specified mux address and port. bool setCustomInitialize ( void ( * pointer )( uint8_t sensorAddress , TwoWire & port , void * _classPtr ), const char * sensorName , uint8_t i2cAddress , uint8_t muxAddress , uint8_t muxPort ) Parameter Type Description pointer void (*)() The address of the custom initialization method sensorName const char * The name of the sensor type i2cAddress uint8_t The I2C address of the target sensor muxAddress uint8_t The I2C address of the mux the sensor is connected to. The default value is 0 (no mux) muxPort uint8_t The mux port the sensor is connected to. The default value is 0 (no mux) return value bool false if no sensors have been detected, otherwise true The parameters for the custom initializer method are: Parameter Type Description sensorAddress uint8_t The I2C address of this sensor port TwoWire & The Wire port this sensor is connected to _classPtr void * A pointer to the class for this sensor type Please see Example4_CustomInitialization for more details. Sensor Names and Readings getSensorReadings() This method collects the readings from all enabled senses on all enabled sensors. The readings are returned in the dynamic char array readings in CSV format. bool getSensorReadings ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true getSensorNames() This method collects the names of all enabled sensors (for all enabled senses). The names are returned in the dynamic char array readings in CSV format. bool getSensorNames ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true getSenseNames() This method collects the names of all enabled senses (for all enabled sensors). The names are returned in the dynamic char array readings in CSV format. bool getSenseNames ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true Menus loggingMenu() This method opens the logging menu on the specified Stream (Serial port) to set the configuration of which sensors and senses are enabled or disabled for logging. bool loggingMenu ( void ) Parameter Type Description return value bool false if no sensors have been detected or the Stream is undefined, otherwise true (when the menu is closed) settingMenu() This method opens the setting menu on the specified Stream (Serial port) to apply settings to any sensors which have them. bool settingMenu ( void ) Parameter Type Description return value bool false if no sensors have been detected or the Stream is undefined or the detected sensors have no settings, otherwise true (when the menu is closed) Sensor and Menu Configuration getSensorAndMenuConfiguration() This method assembles the combined sensor and menu configuration in text CSV format so it can be written to storage media by the appropriate class. The configuration is returned in the dynamic char array configuration . bool getSensorAndMenuConfiguration ( void ) Parameter Type Description return value bool false if no sensors or menu items are found or a memory-allocation error occurred, otherwise true applySensorAndMenuConfiguration() This method applies the configuration in the dynamic char array configuration to the sensors and menu linked-list. The configuration must be read from storage media by the appropriate class before applySensorAndMenuConfiguration is called. The configuration is stored in media in text CSV format. bool applySensorAndMenuConfiguration ( void ) Parameter Type Description return value bool false if no sensors are found or a memory-allocation error occurred, otherwise true Helper Methods sensorExists() This method steps through the sensor linked-list, starting at _head , checking if the specified sensor exists. If it does, it returns a pointer to its SFE_QUAD_Sensor instance. SFE_QUAD_Sensor * sensorExists ( const char * sensorName , uint8_t i2cAddress , uint8_t muxAddress , uint8_t muxPort ) Parameter Type Description sensorName const char * The name of the sensor type i2cAddress uint8_t The I2C address of the target sensor muxAddress uint8_t The I2C address of the mux the sensor is connected to. The default value is 0 (no mux) muxPort uint8_t The mux port the sensor is connected to. The default value is 0 (no mux) return value SFE_QUAD_Sensor * A pointer to the SFE_QUAD_Sensor instance, NULL otherwise getMenuChoice() This method is used by settingMenu and loggingMenu to select one of the menu items. uint32_t getMenuChoice ( unsigned long timeout ) Parameter Type Description timeout unsigned long The menu timeout in milliseconds return value uint32_t The menu choice (>= 1). 0 if the timeout expires getSettingValueDouble() This method is used by settingMenu and loggingMenu . The user enters a double value. Exponent-format entries are accepted. ( settingMenu and loggingMenu will cast the double to the required type.) bool getSettingValueDouble ( double * value , unsigned long timeout ) Parameter Type Description value double * A pointer to the double to hold the value timeout unsigned long The menu timeout in milliseconds return value bool false if no input is received or the Stream is undefined, otherwise true Member Variables Parameter Type Description _head SFE_QUAD_Sensor * The head (start) of the linked-list of SFE_QUAD_Sensor objects readings char * Pointer to a dynamic char array which holds the sensor readings, names or sense names in CSV format configuration char * Pointer to a dynamic char array which holds the sensor and menu configuration _printDebug bool true is debug messages are to be printed to _debugPort , false otherwise _i2cPort TwoWire * Pointer to the Wire port for I2C communication _menuPort Stream * Pointer to the Stream (Serial port) for the built-in menus _debugPort Stream * Pointer to the Stream (Serial port) for the debug messages (if enabled) theMenu SFE_QUAD_Menu Instance of SFE_QUAD_Menu which can be used to create additional menus _sprintf SFE_QUAD_Sensors_sprintf Instance of SFE_QUAD_Sensors_sprintf to aid printing of doubles and exponent-format data","title":"SFE_QUAD_Sensors"},{"location":"api_SFE_QUAD_Sensors/#api-reference-for-the-sfe_quad_sensors-class","text":"Methods to setup, configure and query the SFE_QUAD_Sensor object: Return a pointer to the specified sensor class so it can be added to the linked-list of sensors Define which Wire port will be used Define which Serial port will be used for the built-in menus Detect which sensors are attached Begin those sensors Initialize those sensors (if required) Get the sense readings from all enabled sensors Get the names of all enabled sensors Get the names of all enabled senses Define a custom initializer for a sensor (if required / desired) Determine if a sensor exists Open the logging menu Open the setting menu Get the sensor and menu configuration in text format Apply configuration settings to the sensors and menus","title":"API Reference for the SFE_QUAD_Sensors class"},{"location":"api_SFE_QUAD_Sensors/#brief-overview","text":"The SFE_QUAD_Sensors class allows a linked-list of individual SFE_QUAD_Sensor objects to be generated and maintained. A SFE_QUAD_Sensors object contains a pointer to a SFE_QUAD_Sensor named _head . _head the the head (start) of a linked-list of SFE_QUAD_Sensor objects. _head is NULL initially. After calling detectSensors , it contains the address of the first SFE_QUAD_Sensor in the linked-list. Each SFE_QUAD_Sensor contains a pointer named _next which points to the next SFE_QUAD_Sensor in the linked-list. The _next of the final SFE_QUAD_Sensor in the list is NULL . The possible (known) sensor types are defined in the enum SFEQUADSensorType . detectSensors discovers which individual sensors are attached on the selected Wire port and adds them to the linked-list. detectSensors has built-in Qwiic Mux support and will discover all muxes, and all sensors connected to the ports on those muxes. beginSensors will call the .begin method of each attached sensor in turn. initializeSensors will perform any additional initialization (if any) required by those sensors. It is possible to override the initialization code for each sensor type, or individual sensor objects, by calling setCustomInitialize . (You must call setCustomInitialize before initialzeSensors .) loggingMenu and settingMenu are methods which open built-in menus to: Configure which senses on each sensor are enabled for logging Call any settings methods the sensors may have (if any) The sense readings are stored in a dynamic char array named readings . The enabled senses are read with getSensorReadings . Memory for readings is allocated dynamically (using new ). The memory is freed automatically by the class destructor. The class has been checked for memory leaks - see Example5. The names of all enabled sensors, together with their I2C and Mux addresses (if any), can be read with getSensorNames . The names are returned in readings . The names of all enabled senses can be read with getSenseNames . The names are returned in readings . The sensor and menu configuration can be stored temporarily in a dynamic char array named configuration . The text CSV configuration is written to storage and read from storage by the individual classes for EEPROM, LittleFS, SD and SdFat: SFE_QUAD_Sensors__EEPROM SFE_QUAD_Sensors__LittleFS SFE_QUAD_Sensors__SD SFE_QUAD_Sensors__SdFat Those classes provide additional methods named writeConfigurationToStorage , readConfigurationFromStorage etc. which write and read configuration to and from the appropriate storage medium.","title":"Brief Overview"},{"location":"api_SFE_QUAD_Sensors/#initialization-configuration","text":"","title":"Initialization / Configuration"},{"location":"api_SFE_QUAD_Sensors/#setwireport","text":"This method is called to set the I2C Wire ( TwoWire ) port to which the sensors are connected. void setWirePort ( TwoWire & port ) Parameter Type Description port TwoWire & The Wire port","title":"setWirePort()"},{"location":"api_SFE_QUAD_Sensors/#enabledebugging","text":"This method is called to enable debugging messages on the chosen Stream (usually a Serial port). void enableDebugging ( Stream & port ) Parameter Type Description port Stream & The Stream (Serial port) There is no method to disable the debug messages. The messages can be disabled by setting _printDebug to false: mySensors . _printDebug = false ; This method also enables debug messages on the theMenu object. The menu debug messages can be changed / disabled with the theMenu.setDebugPort method.","title":"enableDebugging()"},{"location":"api_SFE_QUAD_Sensors/#setmenuport","text":"This method sets the Stream (usually a Serial port) for the built-in menus. void setMenuPort ( Stream & port ) Parameter Type Description port Stream & The Stream (Serial port)","title":"setMenuPort()"},{"location":"api_SFE_QUAD_Sensors/#sensor-factory","text":"","title":"Sensor Factory"},{"location":"api_SFE_QUAD_Sensors/#sensorfactory","text":"This method is used internally by the detectSensors method. It returns a pointer to a new instance of a SFE_QUAD_Sensor for the selected type. SFE_QUAD_Sensor * sensorFactory ( SFEQUADSensorType type ) Parameter Type Description type SFEQUADSensorType The enumerated type of the sensor return value SFE_QUAD_Sensor * A pointer to the new sensor instance","title":"sensorFactory()"},{"location":"api_SFE_QUAD_Sensors/#sensor-detection-initialization","text":"","title":"Sensor Detection / Initialization"},{"location":"api_SFE_QUAD_Sensors/#detectsensors","text":"This method discovers which individual sensors are attached on the selected Wire port. It has built-in Qwiic Mux support and will discover all muxes, and all sensors connected to the ports on those muxes. The detected sensors are stored internally as a linked-list, pointed to by _head . bool detectSensors ( void ) Parameter Type Description return value bool false if the Wire port is not defined or a memory-allocation error occurred, otherwise true","title":"detectSensors()"},{"location":"api_SFE_QUAD_Sensors/#beginsensors","text":"This method begins all detected sensors using each sensor's individual .begin method. bool beginSensors ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true","title":"beginSensors()"},{"location":"api_SFE_QUAD_Sensors/#initializesensors","text":"This method initializes any detected sensors if required: only if the library contains initialization code for that sensor type and/or a custom initializer has been defined for that individual sensor or sensor type bool initializeSensors ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true","title":"initializeSensors()"},{"location":"api_SFE_QUAD_Sensors/#setcustominitialize","text":"This method defines custom initialization code for all instances of sensorName . bool setCustomInitialize ( void ( * pointer )( uint8_t sensorAddress , TwoWire & port , void * _classPtr ), const char * sensorName ) Parameter Type Description pointer void (*)() The address of the custom initialization method sensorName const char * The name of the sensor type return value bool false if no sensors have been detected, otherwise true The parameters for the custom initializer method are: Parameter Type Description sensorAddress uint8_t The I2C address of this sensor port TwoWire & The Wire port this sensor is connected to _classPtr void * A pointer to the class for this sensor type return value bool false if no sensors have been detected, otherwise true Please see Example4_CustomInitialization for more details.","title":"setCustomInitialize()"},{"location":"api_SFE_QUAD_Sensors/#setcustominitialize_1","text":"This method defines custom initialization code for the instance of sensorName at the specified mux address and port. bool setCustomInitialize ( void ( * pointer )( uint8_t sensorAddress , TwoWire & port , void * _classPtr ), const char * sensorName , uint8_t i2cAddress , uint8_t muxAddress , uint8_t muxPort ) Parameter Type Description pointer void (*)() The address of the custom initialization method sensorName const char * The name of the sensor type i2cAddress uint8_t The I2C address of the target sensor muxAddress uint8_t The I2C address of the mux the sensor is connected to. The default value is 0 (no mux) muxPort uint8_t The mux port the sensor is connected to. The default value is 0 (no mux) return value bool false if no sensors have been detected, otherwise true The parameters for the custom initializer method are: Parameter Type Description sensorAddress uint8_t The I2C address of this sensor port TwoWire & The Wire port this sensor is connected to _classPtr void * A pointer to the class for this sensor type Please see Example4_CustomInitialization for more details.","title":"setCustomInitialize()"},{"location":"api_SFE_QUAD_Sensors/#sensor-names-and-readings","text":"","title":"Sensor Names and Readings"},{"location":"api_SFE_QUAD_Sensors/#getsensorreadings","text":"This method collects the readings from all enabled senses on all enabled sensors. The readings are returned in the dynamic char array readings in CSV format. bool getSensorReadings ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true","title":"getSensorReadings()"},{"location":"api_SFE_QUAD_Sensors/#getsensornames","text":"This method collects the names of all enabled sensors (for all enabled senses). The names are returned in the dynamic char array readings in CSV format. bool getSensorNames ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true","title":"getSensorNames()"},{"location":"api_SFE_QUAD_Sensors/#getsensenames","text":"This method collects the names of all enabled senses (for all enabled sensors). The names are returned in the dynamic char array readings in CSV format. bool getSenseNames ( void ) Parameter Type Description return value bool false if no sensors have been detected or a memory-allocation error occurred, otherwise true","title":"getSenseNames()"},{"location":"api_SFE_QUAD_Sensors/#menus","text":"","title":"Menus"},{"location":"api_SFE_QUAD_Sensors/#loggingmenu","text":"This method opens the logging menu on the specified Stream (Serial port) to set the configuration of which sensors and senses are enabled or disabled for logging. bool loggingMenu ( void ) Parameter Type Description return value bool false if no sensors have been detected or the Stream is undefined, otherwise true (when the menu is closed)","title":"loggingMenu()"},{"location":"api_SFE_QUAD_Sensors/#settingmenu","text":"This method opens the setting menu on the specified Stream (Serial port) to apply settings to any sensors which have them. bool settingMenu ( void ) Parameter Type Description return value bool false if no sensors have been detected or the Stream is undefined or the detected sensors have no settings, otherwise true (when the menu is closed)","title":"settingMenu()"},{"location":"api_SFE_QUAD_Sensors/#sensor-and-menu-configuration","text":"","title":"Sensor and Menu Configuration"},{"location":"api_SFE_QUAD_Sensors/#getsensorandmenuconfiguration","text":"This method assembles the combined sensor and menu configuration in text CSV format so it can be written to storage media by the appropriate class. The configuration is returned in the dynamic char array configuration . bool getSensorAndMenuConfiguration ( void ) Parameter Type Description return value bool false if no sensors or menu items are found or a memory-allocation error occurred, otherwise true","title":"getSensorAndMenuConfiguration()"},{"location":"api_SFE_QUAD_Sensors/#applysensorandmenuconfiguration","text":"This method applies the configuration in the dynamic char array configuration to the sensors and menu linked-list. The configuration must be read from storage media by the appropriate class before applySensorAndMenuConfiguration is called. The configuration is stored in media in text CSV format. bool applySensorAndMenuConfiguration ( void ) Parameter Type Description return value bool false if no sensors are found or a memory-allocation error occurred, otherwise true","title":"applySensorAndMenuConfiguration()"},{"location":"api_SFE_QUAD_Sensors/#helper-methods","text":"","title":"Helper Methods"},{"location":"api_SFE_QUAD_Sensors/#sensorexists","text":"This method steps through the sensor linked-list, starting at _head , checking if the specified sensor exists. If it does, it returns a pointer to its SFE_QUAD_Sensor instance. SFE_QUAD_Sensor * sensorExists ( const char * sensorName , uint8_t i2cAddress , uint8_t muxAddress , uint8_t muxPort ) Parameter Type Description sensorName const char * The name of the sensor type i2cAddress uint8_t The I2C address of the target sensor muxAddress uint8_t The I2C address of the mux the sensor is connected to. The default value is 0 (no mux) muxPort uint8_t The mux port the sensor is connected to. The default value is 0 (no mux) return value SFE_QUAD_Sensor * A pointer to the SFE_QUAD_Sensor instance, NULL otherwise","title":"sensorExists()"},{"location":"api_SFE_QUAD_Sensors/#getmenuchoice","text":"This method is used by settingMenu and loggingMenu to select one of the menu items. uint32_t getMenuChoice ( unsigned long timeout ) Parameter Type Description timeout unsigned long The menu timeout in milliseconds return value uint32_t The menu choice (>= 1). 0 if the timeout expires","title":"getMenuChoice()"},{"location":"api_SFE_QUAD_Sensors/#getsettingvaluedouble","text":"This method is used by settingMenu and loggingMenu . The user enters a double value. Exponent-format entries are accepted. ( settingMenu and loggingMenu will cast the double to the required type.) bool getSettingValueDouble ( double * value , unsigned long timeout ) Parameter Type Description value double * A pointer to the double to hold the value timeout unsigned long The menu timeout in milliseconds return value bool false if no input is received or the Stream is undefined, otherwise true","title":"getSettingValueDouble()"},{"location":"api_SFE_QUAD_Sensors/#member-variables","text":"Parameter Type Description _head SFE_QUAD_Sensor * The head (start) of the linked-list of SFE_QUAD_Sensor objects readings char * Pointer to a dynamic char array which holds the sensor readings, names or sense names in CSV format configuration char * Pointer to a dynamic char array which holds the sensor and menu configuration _printDebug bool true is debug messages are to be printed to _debugPort , false otherwise _i2cPort TwoWire * Pointer to the Wire port for I2C communication _menuPort Stream * Pointer to the Stream (Serial port) for the built-in menus _debugPort Stream * Pointer to the Stream (Serial port) for the debug messages (if enabled) theMenu SFE_QUAD_Menu Instance of SFE_QUAD_Menu which can be used to create additional menus _sprintf SFE_QUAD_Sensors_sprintf Instance of SFE_QUAD_Sensors_sprintf to aid printing of doubles and exponent-format data","title":"Member Variables"},{"location":"api_SFE_QUAD_Sensors__EEPROM/","text":"API Reference for the SFE_QUAD_Sensors__EEPROM class Methods to support writing/reading the sensors and menu configuration to/from EEPROM storage. Methods beginStorage() This method: initializes the EEPROM; if required it also initializes the CRC-protected configuration structure. bool beginStorage ( void ) Parameter Type Description return value bool true is successful, otherwise false writeConfigurationToStorage() This method writes the menu and sensor configuration from the configuration dynamic char array into EEPROM. The CRC is also updated. If append is false (default) the configuration will be overwritten. If append is true , the configuration is appended to the end of any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false readConfigurationFromStorage() This method reads the menu and sensor configuration from EEPROM, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false endStorage() This method would be used to call the storage's end method - if it had one. For EEPROM, it does nothing and simply returns true . bool endStorage ( void ); Parameter Type Description return value bool Always true","title":"SFE_QUAD_Sensors__EEPROM"},{"location":"api_SFE_QUAD_Sensors__EEPROM/#api-reference-for-the-sfe_quad_sensors__eeprom-class","text":"Methods to support writing/reading the sensors and menu configuration to/from EEPROM storage.","title":"API Reference for the SFE_QUAD_Sensors__EEPROM class"},{"location":"api_SFE_QUAD_Sensors__EEPROM/#methods","text":"","title":"Methods"},{"location":"api_SFE_QUAD_Sensors__EEPROM/#beginstorage","text":"This method: initializes the EEPROM; if required it also initializes the CRC-protected configuration structure. bool beginStorage ( void ) Parameter Type Description return value bool true is successful, otherwise false","title":"beginStorage()"},{"location":"api_SFE_QUAD_Sensors__EEPROM/#writeconfigurationtostorage","text":"This method writes the menu and sensor configuration from the configuration dynamic char array into EEPROM. The CRC is also updated. If append is false (default) the configuration will be overwritten. If append is true , the configuration is appended to the end of any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false","title":"writeConfigurationToStorage()"},{"location":"api_SFE_QUAD_Sensors__EEPROM/#readconfigurationfromstorage","text":"This method reads the menu and sensor configuration from EEPROM, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false","title":"readConfigurationFromStorage()"},{"location":"api_SFE_QUAD_Sensors__EEPROM/#endstorage","text":"This method would be used to call the storage's end method - if it had one. For EEPROM, it does nothing and simply returns true . bool endStorage ( void ); Parameter Type Description return value bool Always true","title":"endStorage()"},{"location":"api_SFE_QUAD_Sensors__LittleFS/","text":"API Reference for the SFE_QUAD_Sensors__LittleFS class Methods to support writing/reading the sensors and menu configuration to/from storage using LittleFS. Methods beginStorage() This method: records the configuration file name; performs a LittleFS.begin() . bool beginStorage ( const char * theFileName ) Parameter Type Description theFilename const char * A pointer to the storage filename return value bool true is successful, otherwise false writeConfigurationToStorage() This method writes the menu and sensor configuration from the configuration dynamic char array into the configuration file. If append is false (default) the configuration file will be overwritten. If append is true , the configuration is appended to the end of the file, preserving any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false readConfigurationFromStorage() This method reads the menu and sensor configuration from storage, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false endStorage() This method performs a LittleFS.end() . bool endStorage ( void ); Parameter Type Description return value bool true if successful, otherwise false Member Variables Parameter Type Description _theStorage File A File object, used to hold the sensor and menu configuration _theStorageName char * A dynamic char array which holds the configuration file name","title":"SFE_QUAD_Sensors__LittleFS"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#api-reference-for-the-sfe_quad_sensors__littlefs-class","text":"Methods to support writing/reading the sensors and menu configuration to/from storage using LittleFS.","title":"API Reference for the SFE_QUAD_Sensors__LittleFS class"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#methods","text":"","title":"Methods"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#beginstorage","text":"This method: records the configuration file name; performs a LittleFS.begin() . bool beginStorage ( const char * theFileName ) Parameter Type Description theFilename const char * A pointer to the storage filename return value bool true is successful, otherwise false","title":"beginStorage()"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#writeconfigurationtostorage","text":"This method writes the menu and sensor configuration from the configuration dynamic char array into the configuration file. If append is false (default) the configuration file will be overwritten. If append is true , the configuration is appended to the end of the file, preserving any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false","title":"writeConfigurationToStorage()"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#readconfigurationfromstorage","text":"This method reads the menu and sensor configuration from storage, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false","title":"readConfigurationFromStorage()"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#endstorage","text":"This method performs a LittleFS.end() . bool endStorage ( void ); Parameter Type Description return value bool true if successful, otherwise false","title":"endStorage()"},{"location":"api_SFE_QUAD_Sensors__LittleFS/#member-variables","text":"Parameter Type Description _theStorage File A File object, used to hold the sensor and menu configuration _theStorageName char * A dynamic char array which holds the configuration file name","title":"Member Variables"},{"location":"api_SFE_QUAD_Sensors__SD/","text":"API Reference for the SFE_QUAD_Sensors__SD class Methods to support writing/reading the sensors and menu configuration to/from storage using the standard Arduino SD library. Methods beginStorage() This method: records the configuration file name; performs a SD.begin() . bool beginStorage ( int csPin , const char * theFileName ) Parameter Type Description csPin int The SPI Chip Select pin theFilename const char * A pointer to the storage filename return value bool true is successful, otherwise false writeConfigurationToStorage() This method writes the menu and sensor configuration from the configuration dynamic char array into the configuration file. If append is false (default) the configuration file will be overwritten. If append is true , the configuration is appended to the end of the file, preserving any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false readConfigurationFromStorage() This method reads the menu and sensor configuration from storage, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false endStorage() This method would be used to call the storage's end method - if it had one. For SD , it does nothing and simply returns true . bool endStorage ( void ); Parameter Type Description return value bool Always true Member Variables Parameter Type Description _theStorage File A File object, used to hold the sensor and menu configuration _theStorageName char * A dynamic char array which holds the configuration file name","title":"SFE_QUAD_Sensors__SD"},{"location":"api_SFE_QUAD_Sensors__SD/#api-reference-for-the-sfe_quad_sensors__sd-class","text":"Methods to support writing/reading the sensors and menu configuration to/from storage using the standard Arduino SD library.","title":"API Reference for the SFE_QUAD_Sensors__SD class"},{"location":"api_SFE_QUAD_Sensors__SD/#methods","text":"","title":"Methods"},{"location":"api_SFE_QUAD_Sensors__SD/#beginstorage","text":"This method: records the configuration file name; performs a SD.begin() . bool beginStorage ( int csPin , const char * theFileName ) Parameter Type Description csPin int The SPI Chip Select pin theFilename const char * A pointer to the storage filename return value bool true is successful, otherwise false","title":"beginStorage()"},{"location":"api_SFE_QUAD_Sensors__SD/#writeconfigurationtostorage","text":"This method writes the menu and sensor configuration from the configuration dynamic char array into the configuration file. If append is false (default) the configuration file will be overwritten. If append is true , the configuration is appended to the end of the file, preserving any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false","title":"writeConfigurationToStorage()"},{"location":"api_SFE_QUAD_Sensors__SD/#readconfigurationfromstorage","text":"This method reads the menu and sensor configuration from storage, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false","title":"readConfigurationFromStorage()"},{"location":"api_SFE_QUAD_Sensors__SD/#endstorage","text":"This method would be used to call the storage's end method - if it had one. For SD , it does nothing and simply returns true . bool endStorage ( void ); Parameter Type Description return value bool Always true","title":"endStorage()"},{"location":"api_SFE_QUAD_Sensors__SD/#member-variables","text":"Parameter Type Description _theStorage File A File object, used to hold the sensor and menu configuration _theStorageName char * A dynamic char array which holds the configuration file name","title":"Member Variables"},{"location":"api_SFE_QUAD_Sensors__SdFat/","text":"API Reference for the SFE_QUAD_Sensors__SdFat class Methods to support writing/reading the sensors and menu configuration to/from storage using SdFat. Methods beginStorage() This method: records the configuration file name; initializes the sd object; changes directory to the SD root directory. bool beginStorage ( int csPin , const char * theFileName ) Parameter Type Description csPin int The SPI Chip Select pin theFilename const char * A pointer to the storage filename return value bool true is successful, otherwise false writeConfigurationToStorage() This method writes the menu and sensor configuration from the configuration dynamic char array into the configuration file. If append is false (default) the configuration file will be overwritten. If append is true , the configuration is appended to the end of the file, preserving any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false readConfigurationFromStorage() This method reads the menu and sensor configuration from storage, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false endStorage() This method would be used to call the storage's end method - if it had one. For SdFat , it does nothing and simply returns true . bool endStorage ( void ); Parameter Type Description return value bool Always true Member Variables Parameter Type Description sd SdFs An instance of the SdFat file system object, used for SD data transfer _theStorage FsFile A SdFat File object, used to hold the sensor and menu configuration _theStorageName char * A dynamic char array which holds the configuration file name","title":"SFE_QUAD_Sensors__SdFat"},{"location":"api_SFE_QUAD_Sensors__SdFat/#api-reference-for-the-sfe_quad_sensors__sdfat-class","text":"Methods to support writing/reading the sensors and menu configuration to/from storage using SdFat.","title":"API Reference for the SFE_QUAD_Sensors__SdFat class"},{"location":"api_SFE_QUAD_Sensors__SdFat/#methods","text":"","title":"Methods"},{"location":"api_SFE_QUAD_Sensors__SdFat/#beginstorage","text":"This method: records the configuration file name; initializes the sd object; changes directory to the SD root directory. bool beginStorage ( int csPin , const char * theFileName ) Parameter Type Description csPin int The SPI Chip Select pin theFilename const char * A pointer to the storage filename return value bool true is successful, otherwise false","title":"beginStorage()"},{"location":"api_SFE_QUAD_Sensors__SdFat/#writeconfigurationtostorage","text":"This method writes the menu and sensor configuration from the configuration dynamic char array into the configuration file. If append is false (default) the configuration file will be overwritten. If append is true , the configuration is appended to the end of the file, preserving any existing configuration data. This can be useful if different sensors are connected for different logging runs. If a sensor configuration is included twice, both will be applied with the newest configuration superseding the older. bool writeConfigurationToStorage ( bool append ) Parameter Type Description append bool If false (default) new data overwrites old. If true , new data is apended to old return value bool true if the data is written successfully, otherwise false","title":"writeConfigurationToStorage()"},{"location":"api_SFE_QUAD_Sensors__SdFat/#readconfigurationfromstorage","text":"This method reads the menu and sensor configuration from storage, copying it into the configuration dynamic char array. bool readConfigurationFromStorage ( void ) Parameter Type Description return value bool true if the data is read successfully, otherwise false","title":"readConfigurationFromStorage()"},{"location":"api_SFE_QUAD_Sensors__SdFat/#endstorage","text":"This method would be used to call the storage's end method - if it had one. For SdFat , it does nothing and simply returns true . bool endStorage ( void ); Parameter Type Description return value bool Always true","title":"endStorage()"},{"location":"api_SFE_QUAD_Sensors__SdFat/#member-variables","text":"Parameter Type Description sd SdFs An instance of the SdFat file system object, used for SD data transfer _theStorage FsFile A SdFat File object, used to hold the sensor and menu configuration _theStorageName char * A dynamic char array which holds the configuration file name","title":"Member Variables"},{"location":"api_SFE_QUAD_Sensors_sprintf/","text":"API Reference for the SFE_QUAD_Sensors_sprintf class Helper methods to support printing of double and exponent-format data. Helper Methods _dtostrf() Convert double to string (included because not all platforms support dtostrf correctly). It is the calling method's responsibility to ensure buffer is large enough to contain the complete string. char * _dtostrf ( double value , char * buffer ) Parameter Type Description value double The double to be converted to string buffer char * A pointer to a char array to hold the text return value char * A pointer to the char after the final one printed _etoa() Convert double to ASCII text using exponent format. It is the calling method's responsibility to ensure buffer is large enough to contain the complete string. char * _etoa ( double value , char * buffer ) Parameter Type Description value double The double to be converted to string buffer char * A pointer to a char array to hold the text return value char * A pointer to the char after the final one printed expStrToDouble() Convert exponent-format string to double. bool expStrToDouble ( const char * str , double * value ) Parameter Type Description str const char * A pointer to the string to be converted value double * A pointer to the double which will hold the result return value bool true if the conversion was successful, false otherwise setPrecision() Set the precision (number of decimal places) to be used by _dtostrf and _etoa . Set this before calling mySensors.detectSensors(); : mySensors._sprintf.setPrecision(5); void setPrecision ( unsigned char prec ) Parameter Type Description prec unsigned char The precision getPrecision() Returns the current precision. unsigned char getPrecision ( void ) Parameter Type Description return value unsigned char The precision Member Variables Parameter Type Description _prec unsigned char The precision (number of decimal places) to be printed","title":"SFE_QUAD_Sensors_sprintf"},{"location":"api_SFE_QUAD_Sensors_sprintf/#api-reference-for-the-sfe_quad_sensors_sprintf-class","text":"Helper methods to support printing of double and exponent-format data.","title":"API Reference for the SFE_QUAD_Sensors_sprintf class"},{"location":"api_SFE_QUAD_Sensors_sprintf/#helper-methods","text":"","title":"Helper Methods"},{"location":"api_SFE_QUAD_Sensors_sprintf/#_dtostrf","text":"Convert double to string (included because not all platforms support dtostrf correctly). It is the calling method's responsibility to ensure buffer is large enough to contain the complete string. char * _dtostrf ( double value , char * buffer ) Parameter Type Description value double The double to be converted to string buffer char * A pointer to a char array to hold the text return value char * A pointer to the char after the final one printed","title":"_dtostrf()"},{"location":"api_SFE_QUAD_Sensors_sprintf/#_etoa","text":"Convert double to ASCII text using exponent format. It is the calling method's responsibility to ensure buffer is large enough to contain the complete string. char * _etoa ( double value , char * buffer ) Parameter Type Description value double The double to be converted to string buffer char * A pointer to a char array to hold the text return value char * A pointer to the char after the final one printed","title":"_etoa()"},{"location":"api_SFE_QUAD_Sensors_sprintf/#expstrtodouble","text":"Convert exponent-format string to double. bool expStrToDouble ( const char * str , double * value ) Parameter Type Description str const char * A pointer to the string to be converted value double * A pointer to the double which will hold the result return value bool true if the conversion was successful, false otherwise","title":"expStrToDouble()"},{"location":"api_SFE_QUAD_Sensors_sprintf/#setprecision","text":"Set the precision (number of decimal places) to be used by _dtostrf and _etoa . Set this before calling mySensors.detectSensors(); : mySensors._sprintf.setPrecision(5); void setPrecision ( unsigned char prec ) Parameter Type Description prec unsigned char The precision","title":"setPrecision()"},{"location":"api_SFE_QUAD_Sensors_sprintf/#getprecision","text":"Returns the current precision. unsigned char getPrecision ( void ) Parameter Type Description return value unsigned char The precision","title":"getPrecision()"},{"location":"api_SFE_QUAD_Sensors_sprintf/#member-variables","text":"Parameter Type Description _prec unsigned char The precision (number of decimal places) to be printed","title":"Member Variables"},{"location":"contribute/","text":"Contribute: Help Make This Library Better! Spot something wrong or which could be improved? Feel free to contribute our open-source software and documentation. Improve our Documentation All of this documentation can be modified by you! Please help us make it better. These pages are contained in the docs folder of the SparkFun Qwiic Universal Auto-Detect repository. Spot something wrong? If a section of the documentation is incorrect, please open an issue and let us know. Submit a Correction or Improvement Fork this repo Add your corrections or improvements to the markdown file or source code File a Pull Request with your changes, and enjoy making the words worlds world a better place. Once received, the code and documentation specialist will automatically be notified. We will review your suggested improvements to make sure they are correct and fit within our standards. Contributors Let's provided some recognition to the contributors for this project!","title":"Contribute"},{"location":"contribute/#contribute-help-make-this-library-better","text":"Spot something wrong or which could be improved? Feel free to contribute our open-source software and documentation.","title":"Contribute: Help Make This Library Better!"},{"location":"contribute/#improve-our-documentation","text":"All of this documentation can be modified by you! Please help us make it better. These pages are contained in the docs folder of the SparkFun Qwiic Universal Auto-Detect repository.","title":"Improve our Documentation"},{"location":"contribute/#spot-something-wrong","text":"If a section of the documentation is incorrect, please open an issue and let us know.","title":"Spot something wrong?"},{"location":"contribute/#submit-a-correction-or-improvement","text":"Fork this repo Add your corrections or improvements to the markdown file or source code File a Pull Request with your changes, and enjoy making the words worlds world a better place. Once received, the code and documentation specialist will automatically be notified. We will review your suggested improvements to make sure they are correct and fit within our standards.","title":"Submit a Correction or Improvement"},{"location":"contribute/#contributors","text":"Let's provided some recognition to the contributors for this project!","title":"Contributors"},{"location":"intro/","text":"Introduction The SparkFun Qwiic Universal Auto-Detect library makes it easy to create a scalable Qwiic (I 2 C) sensing and logging device on a wide range of platforms. We are very proud of OpenLog Artemis . The aim of OLA is simple: provide a system which can automatically detect a wide range of Qwiic sensors and log data from them, all without writing a single line of code. It has been very successful. However, adding new sensors to OLA is quite complicated. There are six files to change and new code needs to be added in multiple places. Also, OLA is, by its nature, tied to the Artemis (Apollo3) platform. With this library we wanted to make a fresh start. The intention is to provide a universal library which can automatically detect, configure and log data from an even wider range of Qwiic sensors and to let it run on multiple platforms. Want to make a logging system which runs on your favourite hardware platform? With this library you can absolutely do that! This library is stand-alone. It contains a built-in copy of the Arduino Library for each sensor. You do not need to worry about installing those libraries yourself. Each time we update the library, we have a script which will automatically include the latest version of the Arduino Library for each sensor. And each time we add a new sensor, the latest Arduino Library for that is included automatically too. All you need to do is keep this single library up to date, via the Arduino Library Manager or by forking or cloning it on GitHub, and everything else happens automatically. The built-in menus make it easy to define and store thing like: the logging interval; a WiFi SSID and password; NTP server names and time zone configuration; ThingSpeak API Key and Channel ID; etc. etc.. If your platform has (e.g.) WiFi or BLE connectivity, this library makes it easy to access the sensor data over those connections. However, you won't find any WiFi or BLE code in this library. Those are layers you can add yourself depending on which hardware platform you are using. As time goes on, we will expand the provided examples showing how you can (e.g.) access the sensor data via an ESP32 WiFi web page. But we won't ever build that functionality directly into the library itself. It then becomes hardware-dependent and that goes against what this library sets out to achieve: hardware-independence! This library contains everything you need to log data from all supported sensors. You do not need a WiFi connection and it does not need to connect to an IO server or dashboard before you can access your sensor data. No account required! When it comes to storing the sensor configuration and menu settings, we've made that as hardware-independent as possible too. You will find support and examples showing how you can store the configuration on microSD card, LittleFS or in EEPROM memory. The examples in this library were written for the SparkFun Thing Plus C - ESP32 WROOM (SPX-18018) but can be adapted for just about any platform. We've even tested it on the good old ATmega328P (as used on the original Uno and RedBoards). The 328P does not have enough memory to hold all of the sensor libraries, but you can enable a small sub-set of sensors (by editing src/SFE_QUAD_Sensors.h ) and still make use of the bulit-in menus!","title":"Introduction"},{"location":"intro/#introduction","text":"The SparkFun Qwiic Universal Auto-Detect library makes it easy to create a scalable Qwiic (I 2 C) sensing and logging device on a wide range of platforms. We are very proud of OpenLog Artemis . The aim of OLA is simple: provide a system which can automatically detect a wide range of Qwiic sensors and log data from them, all without writing a single line of code. It has been very successful. However, adding new sensors to OLA is quite complicated. There are six files to change and new code needs to be added in multiple places. Also, OLA is, by its nature, tied to the Artemis (Apollo3) platform. With this library we wanted to make a fresh start. The intention is to provide a universal library which can automatically detect, configure and log data from an even wider range of Qwiic sensors and to let it run on multiple platforms. Want to make a logging system which runs on your favourite hardware platform? With this library you can absolutely do that! This library is stand-alone. It contains a built-in copy of the Arduino Library for each sensor. You do not need to worry about installing those libraries yourself. Each time we update the library, we have a script which will automatically include the latest version of the Arduino Library for each sensor. And each time we add a new sensor, the latest Arduino Library for that is included automatically too. All you need to do is keep this single library up to date, via the Arduino Library Manager or by forking or cloning it on GitHub, and everything else happens automatically. The built-in menus make it easy to define and store thing like: the logging interval; a WiFi SSID and password; NTP server names and time zone configuration; ThingSpeak API Key and Channel ID; etc. etc.. If your platform has (e.g.) WiFi or BLE connectivity, this library makes it easy to access the sensor data over those connections. However, you won't find any WiFi or BLE code in this library. Those are layers you can add yourself depending on which hardware platform you are using. As time goes on, we will expand the provided examples showing how you can (e.g.) access the sensor data via an ESP32 WiFi web page. But we won't ever build that functionality directly into the library itself. It then becomes hardware-dependent and that goes against what this library sets out to achieve: hardware-independence! This library contains everything you need to log data from all supported sensors. You do not need a WiFi connection and it does not need to connect to an IO server or dashboard before you can access your sensor data. No account required! When it comes to storing the sensor configuration and menu settings, we've made that as hardware-independent as possible too. You will find support and examples showing how you can store the configuration on microSD card, LittleFS or in EEPROM memory. The examples in this library were written for the SparkFun Thing Plus C - ESP32 WROOM (SPX-18018) but can be adapted for just about any platform. We've even tested it on the good old ATmega328P (as used on the original Uno and RedBoards). The 328P does not have enough memory to hold all of the sensor libraries, but you can enable a small sub-set of sensors (by editing src/SFE_QUAD_Sensors.h ) and still make use of the bulit-in menus!","title":"Introduction"},{"location":"new_sensor/","text":"Adding a New Sensor Adding a new sensor is easy! Here is a summary of the steps: Create an SFE_QUAD_Sensor_NewSensorName.h file for it, using the existing files as a template You will find the individual sensor header files in the library src/src sub-folder Edit src/SFE_QUAD_Sensors.h : Add a #define INCLUDE_SFE_QUAD_SENSOR_NewSensorName for the new sensor - in case the user wants to select which sensors to include Add a new entry for the sensor in enum SFEQUADSensorType (3 lines for each new sensor) Add a new entry for the sensor in SFE_QUAD_Sensor * sensorFactory (4 lines for each new sensor) Add a new entry for the sensor in void deleteSensor(SFE_QUAD_Sensor * sensor, SFEQUADSensorType type) (4 lines for each new sensor) Edit src/SFE_QUAD_Headers.h : Add a new entry for the sensor (3 lines for each new sensor) Edit .github/workflows/compile-sketch.yml : Add a - name: Update NewSensorName entry for the new sensor This automates copying the Arduino Library files into the src/src sub-folder The latest versions of the library .h. and .cpp will be copied and added to a GitHub pull request automatically That's all folks! A description of each step is included below: SFE_QUAD_Sensor_NewSensorName.h The SFE_QUAD_Sensor_NewSensorName.h file is the interface between the SparkFun Qwiic Universal Auto-Detect SFE_QUAD_Sensor class and the underlying Arduino Library for that sensor. One of the requirements for SparkFun Qwiic Universal Auto-Detect was to be able to use the existing Arduino Library for any sensor as-is and without modification. The header file provides a standard set of methods to allow the sensor's senses to be: configured; enabled; and read. You can use the existing SFE_QUAD_Sensor_SensorName.h files as a template for the new sensor. If you are adding support for a 'simple' sensor which has no settings and requires no configuration, then the src/src/BME280 header file is a good choice. For a more complex sensor, the src/src/VL53L1X header file is a good starting point. Compiler Guard The first two lines of the header file are a compiler guard . They prevent the file from being included more than once when the code compiles. The name used in the #ifndef and #define must be globally unique. Replace the (e.g.) BME280 with the name of your new sensor. If you are adding a new sensor called FOO , the first two lines become: #ifndef SPARKFUN_QUAD_SENSOR_HEADER_FOO_H // <=== Update this with the new sensor type #define SPARKFUN_QUAD_SENSOR_HEADER_FOO_H // <=== Update this with the new sensor type Header File Name Now is a good time to save the header file using its new name. In this case the file will be saved as: src/src/SFE_QUAD_Sensor_FOO.h #include the Sensor Library Header file Line 4 includes the header file of the Arduino Library for the sensor. The Arduino Library files will be copied into a sub-folder called src/src/FOO . You can, if you wish, create the FOO sub-folder and add the library .h and .cpp files manually. This will allow the code to compile while you are testing it. However, the .github/workflows/compile-sketch.yml file will do this for you automatically once you have edited it. compile-sketch.yml also ensures that the copy of the Arduino Library stays up to date. Any changes to the main Arduino Library are automatically merged into this library whenever changes are pushed. See below for details. Change line 4 so it will include the library header file correctly. #include \"FOO/SparkFun_FOO_Arduino_Library.h\" // <=== Update this with the new sensor library header file !!! note: Always enclose the include file folder and name in double quotes. Do not use less-than and greater-than. This ensures that the copy of the library in the src/src/FOO sub-folder is included, not a copy pointed to by the Arduino IDE path. CLASSNAME and CLASSTITLE CLASSNAME is the name of the sensor class as defined in its Arduino Library. Open the Arduino Library header file to find the name of the class. Copy and paste the name into the #define CLASSNAME . CLASSTITLE is how the sensor class is referred to within Qwiic Universal Auto-Detect. Take the CLASSNAME and prefix it with SFE_QUAD_Sensor_ to form the CLASSTITLE : #define CLASSNAME FOO // <=== Update this with the new sensor type #define CLASSTITLE SFE_QUAD_Sensor_FOO // <=== Update this with the new sensor type SENSE_COUNT The SENSE_COUNT is the number of senses this sensor has. A sensor can have more than one sense. E.g. the BME280 has three: Pressure, Temperature and Humidity. Update the SENSE_COUNT with the number of senses: #define SENSE_COUNT 3 // <=== Update this with the number of things this sensor can sense SETTING_COUNT and CONFIGURATION_ITEM_COUNT The SETTING_COUNT is the number of things which can be set on this sensor. Settings are set one at a time via the built-in setting menu settingMenu . Sensors can also have one or more Configuration Items . These are Settings which need to be stored in storage media (SD, EEPROM, LittleFS) so they can be read and applied easily. Settings are applied manually and individually via the settingMenu . Configuration Items are applied all together with a single call of applySensorAndMenuConfiguration . Settings are usually also Configuration Items , but not always. The number of Settings is usually equal to, or greater than, the number of Configuration Items , but not always. A simple sensor, like the BME280, has zero settings and zero configuration items. A more complex sensor will have one or more settings and configuration items. Change the definitions to match the new sensor: #define SETTING_COUNT 0 // <=== Update this with the number of things that can be set on this sensor #define CONFIGURATION_ITEM_COUNT 0 // <=== Update this with the number of things that can be configured on this sensor Settings vs. Configuration Items The VL53L1X has five settings: Distance Mode: Short Distance Mode: Long Intermeasurement Period Crosstalk Offset But it only has four configuration items requiring storage: Distance Mode Intermeasurement Period Crosstalk Offset We do it this way so that the user can change the distance mode with a single key press. We could have used a single distance mode BOOL setting, representing Short vs. Long, but: The user would have had to select the distance mode setting Then enter a valid BOOL (0 or 1) The code in setSetting would have had to validate the choice before applying it By using two NONE choices, we both make things easier for the user and simplify the code. This is discussed again in setSetting below. SENSOR_I2C_ADDRESSES Sensors usually only have one I 2 C address, but sometimes can have multiple addresses. SENSOR_I2C_ADDRESSES is an array containing all the valid addresses for this sensor. detectSensors will check each address consecutively when detecting which senors are attached. Update SENSOR_I2C_ADDRESSES with the valid addresses for the new sensor: #define SENSOR_I2C_ADDRESSES const uint8_t sensorI2cAddresses[] = {0x76, 0x77} // <=== Update this with the I2C addresses for this sensor detectSensor At the simplest level, we can detect if a sensor is attached by checking if its I 2 C address is acknowledged. A simple I 2 C port scanner will scan through all valid addresses checking for an acknowledgement: for ( int i = 1 ; i < 127 ; i ++ ) { port . beginTransmission ( i ); if ( port . endTransmission () == 0 ) { Serial . print ( \"Something detected at address 0x\" ); Serial . println ( i , HEX ); } } However: Getting an acknowledgement does not tell us what type of sensor was detected at that address, just that something was detected The beginTransmission + endTransmission test can cause some sensors to produce errors A better way is to use the sensor's begin method. However, the begin can sometimes take a long time to complete if no sensor is connected. For the BME280, we use the beginTransmission + endTransmission test as it gives a fast indication of whether a device is connected ( beginI2C is slow if nothing is connected). Followed by its beginI2C method for full confidence that we are detecting a BME280. The BME280 has two valid I 2 C addresses, so we need to tell the code which address to use with the device->setI2CAddress(sensorAddress); . // Detect the sensor. ===> Adapt this to match the sensor type <=== bool detectSensor ( uint8_t sensorAddress , TwoWire & port ) { port . beginTransmission ( sensorAddress ); // Scan the sensor address first. beginI2C takes a long time if no device is connected if ( port . endTransmission () == 0 ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; device -> setI2CAddress ( sensorAddress ); return ( device -> beginI2C ( port )); } else return ( false ); } The VL53L1X's detectSensor is slightly simpler, but again we use the beginTransmission + endTransmission test for speed: // Detect the sensor. ===> Adapt this to match the sensor type <=== bool detectSensor ( uint8_t sensorAddress , TwoWire & port ) { port . beginTransmission ( sensorAddress ); // Scan the sensor address first if ( port . endTransmission () == 0 ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; return ( device -> begin () == 0 ); } else return ( false ); } Adapt the template code to match the new sensor. beginSensor Sensors almost always require their begin method to be called before communication can take place. Again, you should adapt the template code to match the new sensor. The VL53L1X's begin method returns 0 when the device is begun successfully, so its beginSensor is: // Begin the sensor. ===> Adapt this to match the sensor type <=== bool beginSensor ( uint8_t sensorAddress , TwoWire & port ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; return ( device -> begin () == 0 ); } The BME280 returns true when successful, so its beginSensor is: // Begin the sensor. ===> Adapt this to match the sensor type <=== bool beginSensor ( uint8_t sensorAddress , TwoWire & port ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; device -> setI2CAddress ( sensorAddress ); return ( device -> beginI2C ( port )); } The sensor has already been detected, so you do not need to 'scan' the address again, but you do need to call begin again here. The begin in detectSensor is 'lost' as the sensor has not been added to the linked-list of sensors at that point. initializeSensor Each sensor is initialized - if required - when mySensors.initializeSensors(); is called. Some sensors - like the BME280 - don't require initialization. So its initializeSensor is essentially 'empty'. Unless a custom initializer has been defined (see Example4), it simply returns true . If a custom initializer has been defined, then that is called before returning true . // Initialize the sensor. ===> Adapt this to match the sensor type <=== bool initializeSensor ( uint8_t sensorAddress , TwoWire & port ) { if ( _customInitializePtr == NULL ) // Has a custom initialize function been defined? { return ( true ); } else { _customInitializePtr ( sensorAddress , port , _classPtr ); // Call the custom initialize function return ( true ); } } The VL53L1X does require initialization. As a minimum, we need to set the distance mode and instruct it to startRanging : // Initialize the sensor. ===> Adapt this to match the sensor type <=== bool initializeSensor ( uint8_t sensorAddress , TwoWire & port ) { if ( _customInitializePtr == NULL ) // Has a custom initialize function been defined? { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; if ( _shortDistanceMode ) device -> setDistanceModeShort (); else device -> setDistanceModeLong (); device -> startRanging (); return ( true ); } else { _customInitializePtr ( sensorAddress , port , _classPtr ); // Call the custom initialize function return ( true ); } } _shortDistanceMode is an extra bool member variable we've added to the sensor class. It is initialized to true when the sensor object is created and added to the linked list: bool _shortDistanceMode ; CLASSTITLE ( TwoWire & port ) { _sensorAddress = 0 ; _muxAddress = 0 ; _muxPort = 0 ; _classPtr = new CLASSNAME ( port ); _next = NULL ; _logSense = new bool [ SENSE_COUNT + 1 ]; for ( size_t i = 0 ; i <= SENSE_COUNT ; i ++ ) _logSense [ i ] = true ; _customInitializePtr = NULL ; _shortDistanceMode = true ; } _shortDistanceMode records or indicates whether the sensor is in short or long distance mode. Why did we do it this way? Couldn't we have used a BOOL configuration item for it instead? Yes, we could have done it that way, but, as we explained above: The user would have had to select the distance mode setting Then enter a valid BOOL (0 or 1) The code in setSetting would have had to validate the choice before applying it By using two NONE choices, and storing the choice in _shortDistanceMode , we both make things easier for the user and simplify the code. getSenseName getSenseName returns the name of each sense as const char * as it will appear in loggingMenu . The number of case statements must match SENSE_COUNT . Adapt the template code to match the number of senses for the new sensor; add or remove case statements as necessary. // Return the name of the name of the specified sense. ===> Adapt this to match the sensor type <=== const char * getSenseName ( uint8_t sense ) { switch ( sense ) { case 0 : return ( \"Pressure (Pa)\" ); break ; case 1 : return ( \"Temperature (C)\" ); break ; case 2 : return ( \"Humidity (%)\" ); break ; default : return ( NULL ); break ; } return ( NULL ); } getSenseReading getSenseReading is the method which calls the appropriate 'read' method for the selected sense . It is called by getSensorReadings . getSenseReading calls the Arduino Library method to read that sense and converts the reading into text format: // Return the specified sense reading as text. ===> Adapt this to match the sensor type <=== bool getSenseReading ( uint8_t sense , char * reading ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( sense ) { case 0 : _sprintf . _dtostrf (( double ) device -> readFloatPressure (), reading ); // Get the pressure return ( true ); break ; case 1 : _sprintf . _dtostrf (( double ) device -> readTempC (), reading ); // Get the temperature return ( true ); break ; case 2 : _sprintf . _dtostrf (( double ) device -> readFloatHumidity (), reading ); // Get the humidity return ( true ); break ; default : return ( false ); break ; } return ( false ); } Again, the number of case statements must match SENSE_COUNT . And, of course, the order of the case statements must be the same as getSenseName . Looking closely at the code for the Pressure (sense 0): _sprintf._dtostrf((double)device->readFloatPressure(), reading); The code is: Calling the Arduino Library readFloatPressure() method, using the _classPtr The result is being cast to double _sprintf._dtostrf is a helper function from the SFE_QUAD_Sensors_sprintf class which converts the double to text sprintf is not supported correctly on all platforms (Artemis / Apollo3 especially) so we added the helper method to the sensor class to ensure doubles are always converted to text correctly The text is copied into the char array reading If you like exponent-format , there is an additional helper function named _sprintf._etoa which will convert a double to exponent-format text. getSensorReadings pieces the text readings together in CSV format and retruns them in readings . If the sense methods return an integer (instead of float or double), then getSensorReadings does use sprintf to print the reading as text: // Return the specified sense reading as text. ===> Adapt this to match the sensor type <=== bool getSenseReading ( uint8_t sense , char * reading ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( sense ) { case 0 : sprintf ( reading , \"%d\" , device -> getDistance ()); return ( true ); break ; case 1 : sprintf ( reading , \"%d\" , device -> getRangeStatus ()); return ( true ); break ; case 2 : sprintf ( reading , \"%d\" , device -> getSignalRate ()); return ( true ); break ; default : return ( false ); break ; } return ( false ); } getSettingName Simple sensors, like the BME280, have no settings or configuration items. getSettingName simply returns NULL . // Return the name of the name of the specified setting. ===> Adapt this to match the sensor type <=== const char * getSettingName ( uint8_t setting ) { switch ( setting ) { default : return ( NULL ); break ; } return ( NULL ); } For the VL53L1X, getSettingName returns the name of each setting as it will appear in settingMenu : // Return the name of the name of the specified setting. ===> Adapt this to match the sensor type <=== const char * getSettingName ( uint8_t setting ) { switch ( setting ) { case 0 : return ( \"Distance Mode: Short\" ); break ; case 1 : return ( \"Distance Mode: Long\" ); break ; case 2 : return ( \"Intermeasurement Period\" ); break ; case 3 : return ( \"Crosstalk\" ); break ; case 4 : return ( \"Offset\" ); break ; default : return ( NULL ); break ; } return ( NULL ); } The number of case statements must match SETTING_COUNT . getSettingType getSettingType returns the SFE_QUAD_Sensor_Setting_Type_e data type for the setting. If the sensor has no settings ( SETTING_COUNT is zero), then getSettingType simply returns false: // Return the type of the specified setting. ===> Adapt this to match the sensor type <=== bool getSettingType ( uint8_t setting , SFE_QUAD_Sensor_Setting_Type_e * type ) { switch ( setting ) { default : return ( false ); break ; } return ( true ); } But if there are settings, it returns the data type which matches the type required by the Arduino Library setting method: // Return the type of the specified setting. ===> Adapt this to match the sensor type <=== bool getSettingType ( uint8_t setting , SFE_QUAD_Sensor_Setting_Type_e * type ) { switch ( setting ) { case 0 : case 1 : * type = SFE_QUAD_SETTING_TYPE_NONE ; break ; case 2 : case 3 : case 4 : * type = SFE_QUAD_SETTING_TYPE_UINT16_T ; break ; default : return ( false ); break ; } return ( true ); } The SFE_QUAD_Sensor_Setting_Type_e setting types are: SFE_QUAD_SETTING_TYPE_NONE SFE_QUAD_SETTING_TYPE_BOOL SFE_QUAD_SETTING_TYPE_FLOAT SFE_QUAD_SETTING_TYPE_DOUBLE SFE_QUAD_SETTING_TYPE_INT SFE_QUAD_SETTING_TYPE_UINT8_T SFE_QUAD_SETTING_TYPE_UINT16_T SFE_QUAD_SETTING_TYPE_UINT32_T All except NONE are self explanatory. If the Arduino Library setting method requires an int then set *type to SFE_QUAD_SETTING_TYPE_INT . Etc.. If the setting type is anything other than NONE , the settingMenu will call getSettingValueDouble and cast the result to the appropriate type before calling setSetting . The NONE type has no value, it simply causes the menu to do something when that menu option is selected. Looking at the code above, the NONE type is used for settings 0 and 1: \"Distance Mode: Short\" and \"Distance Mode: Long\". The matching code in setSetting then does something without needing a value from getSettingValueDouble . For the other three cases, a uint16_t will be passed to setSetting since that is what the Arduino Library methods require. setSetting If the sensor has no settings ( SETTING_COUNT is zero), then setSetting simply returns false: // Set the specified setting. ===> Adapt this to match the sensor type <=== bool setSetting ( uint8_t setting , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( setting ) { default : return ( false ); break ; } return ( true ); } But for sensors like the VL53L1X, we do of course want setSettings to do something. Let's break it down into case 0-1 and 2-4: // Set the specified setting. ===> Adapt this to match the sensor type <=== bool setSetting ( uint8_t setting , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( setting ) { case 0 : device -> stopRanging (); _shortDistanceMode = true ; device -> setDistanceModeShort (); device -> startRanging (); break ; case 1 : device -> stopRanging (); _shortDistanceMode = false ; device -> setDistanceModeLong (); if ( device -> getIntermeasurementPeriod () < 140 ) device -> setIntermeasurementPeriod ( 140 ); device -> startRanging (); break ; For the two NONE types, settings 0 and 1: \"Distance Mode: Short\" and \"Distance Mode: Long\" the code in the case statement changes the sensor's distance mode accordingly. For case 0 (\"Distance Mode: Short\"), setSetting : Stops the sensor with its stopRanging() method Sets the member variable _shortDistanceMode to true so we have a record of the mode Sets the distance mode to short with setDistanceModeShort() (Re)starts the sensor with startRanging() The code for case 1 (\"Distance Mode: Long\") is similar, except: _shortDistanceMode is set to false For the long distance mode, the sensor's measurement period cannot be shorter than 140. The measurement period is increased if necessary For settings cases 2-4, the UINT16_T setting value is checked to make sure it is within the correct limits and is then passed to the Arduino Library set method: case 2 : device -> stopRanging (); if ( value -> UINT16_T < 20 ) value -> UINT16_T = 20 ; if ( ! _shortDistanceMode ) if ( value -> UINT16_T < 140 ) value -> UINT16_T = 140 ; if ( value -> UINT16_T > 1000 ) value -> UINT16_T = 1000 ; device -> setIntermeasurementPeriod ( value -> UINT16_T ); device -> startRanging (); break ; case 3 : device -> stopRanging (); if ( value -> UINT16_T > 4000 ) value -> UINT16_T = 4000 ; device -> setXTalk ( value -> UINT16_T ); device -> startRanging (); break ; case 4 : device -> stopRanging (); if ( value -> UINT16_T > 4000 ) value -> UINT16_T = 4000 ; device -> setOffset ( value -> UINT16_T ); device -> startRanging (); break ; default : return ( false ); break ; } return ( true ); } getConfigurationItemName The Configuration Item methods are almost identical to the Settings methods. Remember that Configuration Items are simply Settings which can be written to and read from storage. For the VL53L1X, \"Distance Mode: Short\" and \"Distance Mode: Long\" are combined into a BOOL for storage. But, other than that, the Configuration Items match the Settings. getConfigurationItemName returns a pointer to the name of each configuration item. The number of case statements must match CONFIGURATION_ITEM_COUNT . Some important points: Configuration Item names must not contain spaces Use underscores where necessary The names should be unique Keep the names short but meaningful Use abbreviations where possible These names occupy storage media space which - for EEPROM - can be limited Never use commas in the names The configurations are stored in CSV format // Return the name of the configuration item // Use underscores, not spaces const char * getConfigurationItemName ( uint8_t configItem ) { switch ( configItem ) { case 0 : return ( \"Dist_Mode\" ); break ; case 1 : return ( \"IM_Period\" ); break ; case 2 : return ( \"Xtalk\" ); break ; case 3 : return ( \"Offset\" ); break ; default : return ( NULL ); break ; } return ( NULL ); } getConfigurationItemType getConfigurationItemType is very similar to getSettingType . For the VL53L1X, the only difference is that the two distance mode NONE types have been integrated into a single BOOL // Return the type of the specified configuration item bool getConfigurationItemType ( uint8_t configItem , SFE_QUAD_Sensor_Setting_Type_e * type ) { switch ( configItem ) { case 0 : * type = SFE_QUAD_SETTING_TYPE_BOOL ; break ; case 1 : case 2 : case 3 : * type = SFE_QUAD_SETTING_TYPE_UINT16_T ; break ; default : return ( false ); break ; } return ( true ); } getConfigurationItem getConfigurationItem calls the Arduino Library's get function for that configuration item. The value is returned in the appropriate field of the SFE_QUAD_Sensor_Every_Type_t . For the VL53L1X, the three uint16_t configuration items are returned in value->UINT16_T . The distance mode (config item 0) is simply read from the _shortDistanceMode member variable. We could have made use of the Library's getDistanceMode method and converted the return value (1 or 2) to bool . Doing it this way avoids an unnecessary I 2 C bus transaction. // Get (read) the sensor configuration item bool getConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( configItem ) { case 0 : value -> BOOL = _shortDistanceMode ; break ; case 1 : value -> UINT16_T = device -> getIntermeasurementPeriod (); break ; case 2 : value -> UINT16_T = device -> getXTalk (); break ; case 3 : value -> UINT16_T = device -> getOffset (); break ; default : return ( false ); break ; } return ( true ); } setConfigurationItem setConfigurationItem is very similar to setSetting . For the VL53L1X's distance mode, we use the value read from storage to update the _shortDistanceMode member variable. // Set (write) the sensor configuration item bool setConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( configItem ) { case 0 : _shortDistanceMode = value -> BOOL ; device -> stopRanging (); if ( _shortDistanceMode ) device -> setDistanceModeShort (); else device -> setDistanceModeLong (); device -> startRanging (); break ; case 1 : device -> stopRanging (); device -> setIntermeasurementPeriod ( value -> UINT16_T ); device -> startRanging (); break ; case 2 : device -> stopRanging (); device -> setXTalk ( value -> UINT16_T ); device -> startRanging (); break ; case 3 : device -> stopRanging (); device -> setOffset ( value -> UINT16_T ); device -> startRanging (); break ; default : return ( false ); break ; } return ( true ); } SFE_QUAD_Sensors.h When adding a new sensor, src/SFE_QUAD_Sensors.h needs to be modified in three places: INCLUDE_SFE_QUAD_SENSOR_NewSensorName Add a #define INCLUDE_SFE_QUAD_SENSOR_NewSensorName for the new sensor. This allows the user to select which sensors to include in the code build. By default, all sensors are included. Only including selected sensors speeds up the compilation time and reduces the amount of program memory used. However, SFE_QUAD_Sensors.h will be overwritten each time the library is updated. We have not (yet) been able to find a way of defining which sensors to include in the main .ino file. If you can think of a way of doing this - which works on all platforms - then please send us a Pull Request! For our fictitious FOO sensor, we would insert the #define in alphabetical order after CCS811 : // To select which sensors to include: // comment #define INCLUDE_SFE_QUAD_SENSOR_ALL // uncomment one or more #define INCLUDE_SFE_QUAD_SENSOR_ //#define INCLUDE_SFE_QUAD_SENSOR_ADS122C04 // Include individual sensors //#define INCLUDE_SFE_QUAD_SENSOR_AHT20 //#define INCLUDE_SFE_QUAD_SENSOR_BME280 //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5A //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5B //#define INCLUDE_SFE_QUAD_SENSOR_FOO The alphabetical ordering is not important, it just makes the list quicker to read. SFEQUADSensorType Scrolling ~halfway down SFE_QUAD_Sensors.h , you will find enum SFEQUADSensorType near the start of the class SFE_QUAD_Sensors . We need to add three lines for the new sensor. The ordering here is important as the enum SFEQUADSensorType is stored with each Configuration Item . The new sensor must be added to the end of the enum just before SFE_QUAD_Sensor_Number_Of_Sensors . Inserting it anywhere else will prevent existing saved configurations being used with the updated library. #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_VL53L1X) Sensor_VL53L1X , #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) Sensor_FOO , #endif SFE_QUAD_Sensor_Number_Of_Sensors // Must be last. <=== Add new sensors _above this line_ to preserve the existing enum values }; However, if you look closely at enum SFEQUADSensorType , you will see that the MS8607 appears before the MS5637 . #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_MS8607) // MS8607 must be before MS5637 (otherwise MS8607 will appear as a MS5637) Sensor_MS8607 , #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_MS5637) Sensor_MS5637 , #endif This is because the MS8607 is essentially a MS5637 with an additional built-in humidity sensor (with its own I 2 C address). The MS8607 must be detected before the MS5637 otherwise it will appear as a MS5637 and a MS8607. detectSensors contains some additional code to prevent the re-detection of an MS8607 as a MS5637. There may be similar cases where it is necessary to detect sensors in a particular order and for the new sensor to be inserted part-way through enum SFEQUADSensorType . If that happens, and you are sending us a Pull Request, please make this clear in the notes. We may still be able to merge your Pull Request, but we will need to make everyone aware that the new version is not backward-compatible with saved configurations from previous versions. sensorFactory We need to add the new sensor to the sensorFactory . This is the method which returns a new object of the requested sensor class. The order here is not important. Insert the new sensor alphabetically (unless there is a good reason not to): #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_CCS811_5B) if ( type == Sensor_CCS811_5B ) return new SFE_QUAD_Sensor_CCS811_5B ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) if ( type == Sensor_FOO ) return new SFE_QUAD_Sensor_FOO ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_LPS25HB) if ( type == Sensor_LPS25HB ) return new SFE_QUAD_Sensor_LPS25HB ; #endif deleteSensor The final change to SFE_QUAD_Sensors.h is to add the new sensor to the deleteSensor . This is the method which deletes the sensor in a safe way, casting sensor to the correct class. The order here is not important. Insert the new sensor alphabetically (unless there is a good reason not to): #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_CCS811_5B) if ( type == Sensor_CCS811_5B ) delete ( SFE_QUAD_Sensor_CCS811_5B * ) sensor ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) if ( type == Sensor_FOO ) delete ( SFE_QUAD_Sensor_FOO * ) sensor ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_LPS25HB) if ( type == Sensor_LPS25HB ) delete ( SFE_QUAD_Sensor_LPS25HB * ) sensor ; #endif SFE_QUAD_Headers.h When adding a new sensor, src/SFE_QUAD_Headers.h needs to be modified to include the header file for the new sensor. The order here is not important. Insert the new sensor alphabetically (unless there is a good reason not to): #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_CCS811_5B) #include \"src/SFE_QUAD_Sensor_CCS811_5B.h\" #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) #include \"src/SFE_QUAD_Sensor_FOO.h\" #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_LPS25HB) #include \"src/SFE_QUAD_Sensor_LPS25HB.h\" #endif .github/workflows/compile-sketch.yml The final change is to update .github/workflows/compile-sketch.yml to include the new sensor's Arduino Library. Any changes to the sensor's Arduino Library are automatically merged into the copy in this library. That way, this library stays up to date with any and all changes to the individual Arduino Libraries. The entry for our fictitious FOO sensor would be something like: - name : Update FOO run : | cd . / src / src / mkdir - p FOO cd FOO curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.cpp You need to include the full raw.githubusercontent.com address for the library files: Navigate to the Arduino Library on GitHub Navigate to the src sub-folder Open the .h file Click the RAW button to view the file's raw content Copy and paste the address from your browser into compile-sketch.yml Repeat for the .cpp file If the Arduino Library contains more than the standard .h and .cpp files, include those too. E.g. looking at the SGP40: - name : Update SGP40 run : | cd . / src / src / mkdir - p SGP40 cd SGP40 curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/SparkFun_SGP40_Arduino_Library.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/SparkFun_SGP40_Arduino_Library.cpp curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/sensirion_arch_config.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/sensirion_voc_algorithm.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/sensirion_voc_algorithm.c Finally, you need to check how the .cpp file includes its .h file. In Arduino examples, you will often see files included like this: #include <SparkFun_FOO_Arduino_Library.h> The less-than and greater-than tell the Arduino IDE compiler to search its PATH for SparkFun_FOO_Arduino_Library.h . SparkFun_FOO_Arduino_Library.h will normally be in a \\library sub-folder. For this library, we want to ensure the copy of the Arduino Library in the src\\src sub-folder is used, not the copy from the IDE PATH . Look inside the .cpp file. If you see: #include <SparkFun_FOO_Arduino_Library.h> then you need to include one extra line in compile-sketch.yml so that the less-than and greater-than are replaced automatically with double-quotes: - name : Update FOO run : | cd . / src / src / mkdir - p FOO cd FOO curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.cpp # SparkFun_FOO_Arduino_Library.cpp uses #include <SparkFun_FOO_Arduino_Library.h>. We need to replace the < and > with double quotes sed - i ' s /< SparkFun_FOO_Arduino_Library . h >/ '\\\"' SparkFun_FOO_Arduino_Library . h '\\\"' / g ' SparkFun_FOO_Arduino_Library . cpp","title":"Adding a New Sensor"},{"location":"new_sensor/#adding-a-new-sensor","text":"Adding a new sensor is easy! Here is a summary of the steps: Create an SFE_QUAD_Sensor_NewSensorName.h file for it, using the existing files as a template You will find the individual sensor header files in the library src/src sub-folder Edit src/SFE_QUAD_Sensors.h : Add a #define INCLUDE_SFE_QUAD_SENSOR_NewSensorName for the new sensor - in case the user wants to select which sensors to include Add a new entry for the sensor in enum SFEQUADSensorType (3 lines for each new sensor) Add a new entry for the sensor in SFE_QUAD_Sensor * sensorFactory (4 lines for each new sensor) Add a new entry for the sensor in void deleteSensor(SFE_QUAD_Sensor * sensor, SFEQUADSensorType type) (4 lines for each new sensor) Edit src/SFE_QUAD_Headers.h : Add a new entry for the sensor (3 lines for each new sensor) Edit .github/workflows/compile-sketch.yml : Add a - name: Update NewSensorName entry for the new sensor This automates copying the Arduino Library files into the src/src sub-folder The latest versions of the library .h. and .cpp will be copied and added to a GitHub pull request automatically That's all folks! A description of each step is included below:","title":"Adding a New Sensor"},{"location":"new_sensor/#sfe_quad_sensor_newsensornameh","text":"The SFE_QUAD_Sensor_NewSensorName.h file is the interface between the SparkFun Qwiic Universal Auto-Detect SFE_QUAD_Sensor class and the underlying Arduino Library for that sensor. One of the requirements for SparkFun Qwiic Universal Auto-Detect was to be able to use the existing Arduino Library for any sensor as-is and without modification. The header file provides a standard set of methods to allow the sensor's senses to be: configured; enabled; and read. You can use the existing SFE_QUAD_Sensor_SensorName.h files as a template for the new sensor. If you are adding support for a 'simple' sensor which has no settings and requires no configuration, then the src/src/BME280 header file is a good choice. For a more complex sensor, the src/src/VL53L1X header file is a good starting point.","title":"SFE_QUAD_Sensor_NewSensorName.h"},{"location":"new_sensor/#compiler-guard","text":"The first two lines of the header file are a compiler guard . They prevent the file from being included more than once when the code compiles. The name used in the #ifndef and #define must be globally unique. Replace the (e.g.) BME280 with the name of your new sensor. If you are adding a new sensor called FOO , the first two lines become: #ifndef SPARKFUN_QUAD_SENSOR_HEADER_FOO_H // <=== Update this with the new sensor type #define SPARKFUN_QUAD_SENSOR_HEADER_FOO_H // <=== Update this with the new sensor type","title":"Compiler Guard"},{"location":"new_sensor/#header-file-name","text":"Now is a good time to save the header file using its new name. In this case the file will be saved as: src/src/SFE_QUAD_Sensor_FOO.h","title":"Header File Name"},{"location":"new_sensor/#include-the-sensor-library-header-file","text":"Line 4 includes the header file of the Arduino Library for the sensor. The Arduino Library files will be copied into a sub-folder called src/src/FOO . You can, if you wish, create the FOO sub-folder and add the library .h and .cpp files manually. This will allow the code to compile while you are testing it. However, the .github/workflows/compile-sketch.yml file will do this for you automatically once you have edited it. compile-sketch.yml also ensures that the copy of the Arduino Library stays up to date. Any changes to the main Arduino Library are automatically merged into this library whenever changes are pushed. See below for details. Change line 4 so it will include the library header file correctly. #include \"FOO/SparkFun_FOO_Arduino_Library.h\" // <=== Update this with the new sensor library header file !!! note: Always enclose the include file folder and name in double quotes. Do not use less-than and greater-than. This ensures that the copy of the library in the src/src/FOO sub-folder is included, not a copy pointed to by the Arduino IDE path.","title":"#include the Sensor Library Header file"},{"location":"new_sensor/#classname-and-classtitle","text":"CLASSNAME is the name of the sensor class as defined in its Arduino Library. Open the Arduino Library header file to find the name of the class. Copy and paste the name into the #define CLASSNAME . CLASSTITLE is how the sensor class is referred to within Qwiic Universal Auto-Detect. Take the CLASSNAME and prefix it with SFE_QUAD_Sensor_ to form the CLASSTITLE : #define CLASSNAME FOO // <=== Update this with the new sensor type #define CLASSTITLE SFE_QUAD_Sensor_FOO // <=== Update this with the new sensor type","title":"CLASSNAME and CLASSTITLE"},{"location":"new_sensor/#sense_count","text":"The SENSE_COUNT is the number of senses this sensor has. A sensor can have more than one sense. E.g. the BME280 has three: Pressure, Temperature and Humidity. Update the SENSE_COUNT with the number of senses: #define SENSE_COUNT 3 // <=== Update this with the number of things this sensor can sense","title":"SENSE_COUNT"},{"location":"new_sensor/#setting_count-and-configuration_item_count","text":"The SETTING_COUNT is the number of things which can be set on this sensor. Settings are set one at a time via the built-in setting menu settingMenu . Sensors can also have one or more Configuration Items . These are Settings which need to be stored in storage media (SD, EEPROM, LittleFS) so they can be read and applied easily. Settings are applied manually and individually via the settingMenu . Configuration Items are applied all together with a single call of applySensorAndMenuConfiguration . Settings are usually also Configuration Items , but not always. The number of Settings is usually equal to, or greater than, the number of Configuration Items , but not always. A simple sensor, like the BME280, has zero settings and zero configuration items. A more complex sensor will have one or more settings and configuration items. Change the definitions to match the new sensor: #define SETTING_COUNT 0 // <=== Update this with the number of things that can be set on this sensor #define CONFIGURATION_ITEM_COUNT 0 // <=== Update this with the number of things that can be configured on this sensor","title":"SETTING_COUNT and CONFIGURATION_ITEM_COUNT"},{"location":"new_sensor/#settings-vs-configuration-items","text":"The VL53L1X has five settings: Distance Mode: Short Distance Mode: Long Intermeasurement Period Crosstalk Offset But it only has four configuration items requiring storage: Distance Mode Intermeasurement Period Crosstalk Offset We do it this way so that the user can change the distance mode with a single key press. We could have used a single distance mode BOOL setting, representing Short vs. Long, but: The user would have had to select the distance mode setting Then enter a valid BOOL (0 or 1) The code in setSetting would have had to validate the choice before applying it By using two NONE choices, we both make things easier for the user and simplify the code. This is discussed again in setSetting below.","title":"Settings vs. Configuration Items"},{"location":"new_sensor/#sensor_i2c_addresses","text":"Sensors usually only have one I 2 C address, but sometimes can have multiple addresses. SENSOR_I2C_ADDRESSES is an array containing all the valid addresses for this sensor. detectSensors will check each address consecutively when detecting which senors are attached. Update SENSOR_I2C_ADDRESSES with the valid addresses for the new sensor: #define SENSOR_I2C_ADDRESSES const uint8_t sensorI2cAddresses[] = {0x76, 0x77} // <=== Update this with the I2C addresses for this sensor","title":"SENSOR_I2C_ADDRESSES"},{"location":"new_sensor/#detectsensor","text":"At the simplest level, we can detect if a sensor is attached by checking if its I 2 C address is acknowledged. A simple I 2 C port scanner will scan through all valid addresses checking for an acknowledgement: for ( int i = 1 ; i < 127 ; i ++ ) { port . beginTransmission ( i ); if ( port . endTransmission () == 0 ) { Serial . print ( \"Something detected at address 0x\" ); Serial . println ( i , HEX ); } } However: Getting an acknowledgement does not tell us what type of sensor was detected at that address, just that something was detected The beginTransmission + endTransmission test can cause some sensors to produce errors A better way is to use the sensor's begin method. However, the begin can sometimes take a long time to complete if no sensor is connected. For the BME280, we use the beginTransmission + endTransmission test as it gives a fast indication of whether a device is connected ( beginI2C is slow if nothing is connected). Followed by its beginI2C method for full confidence that we are detecting a BME280. The BME280 has two valid I 2 C addresses, so we need to tell the code which address to use with the device->setI2CAddress(sensorAddress); . // Detect the sensor. ===> Adapt this to match the sensor type <=== bool detectSensor ( uint8_t sensorAddress , TwoWire & port ) { port . beginTransmission ( sensorAddress ); // Scan the sensor address first. beginI2C takes a long time if no device is connected if ( port . endTransmission () == 0 ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; device -> setI2CAddress ( sensorAddress ); return ( device -> beginI2C ( port )); } else return ( false ); } The VL53L1X's detectSensor is slightly simpler, but again we use the beginTransmission + endTransmission test for speed: // Detect the sensor. ===> Adapt this to match the sensor type <=== bool detectSensor ( uint8_t sensorAddress , TwoWire & port ) { port . beginTransmission ( sensorAddress ); // Scan the sensor address first if ( port . endTransmission () == 0 ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; return ( device -> begin () == 0 ); } else return ( false ); } Adapt the template code to match the new sensor.","title":"detectSensor"},{"location":"new_sensor/#beginsensor","text":"Sensors almost always require their begin method to be called before communication can take place. Again, you should adapt the template code to match the new sensor. The VL53L1X's begin method returns 0 when the device is begun successfully, so its beginSensor is: // Begin the sensor. ===> Adapt this to match the sensor type <=== bool beginSensor ( uint8_t sensorAddress , TwoWire & port ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; return ( device -> begin () == 0 ); } The BME280 returns true when successful, so its beginSensor is: // Begin the sensor. ===> Adapt this to match the sensor type <=== bool beginSensor ( uint8_t sensorAddress , TwoWire & port ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; device -> setI2CAddress ( sensorAddress ); return ( device -> beginI2C ( port )); } The sensor has already been detected, so you do not need to 'scan' the address again, but you do need to call begin again here. The begin in detectSensor is 'lost' as the sensor has not been added to the linked-list of sensors at that point.","title":"beginSensor"},{"location":"new_sensor/#initializesensor","text":"Each sensor is initialized - if required - when mySensors.initializeSensors(); is called. Some sensors - like the BME280 - don't require initialization. So its initializeSensor is essentially 'empty'. Unless a custom initializer has been defined (see Example4), it simply returns true . If a custom initializer has been defined, then that is called before returning true . // Initialize the sensor. ===> Adapt this to match the sensor type <=== bool initializeSensor ( uint8_t sensorAddress , TwoWire & port ) { if ( _customInitializePtr == NULL ) // Has a custom initialize function been defined? { return ( true ); } else { _customInitializePtr ( sensorAddress , port , _classPtr ); // Call the custom initialize function return ( true ); } } The VL53L1X does require initialization. As a minimum, we need to set the distance mode and instruct it to startRanging : // Initialize the sensor. ===> Adapt this to match the sensor type <=== bool initializeSensor ( uint8_t sensorAddress , TwoWire & port ) { if ( _customInitializePtr == NULL ) // Has a custom initialize function been defined? { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; if ( _shortDistanceMode ) device -> setDistanceModeShort (); else device -> setDistanceModeLong (); device -> startRanging (); return ( true ); } else { _customInitializePtr ( sensorAddress , port , _classPtr ); // Call the custom initialize function return ( true ); } } _shortDistanceMode is an extra bool member variable we've added to the sensor class. It is initialized to true when the sensor object is created and added to the linked list: bool _shortDistanceMode ; CLASSTITLE ( TwoWire & port ) { _sensorAddress = 0 ; _muxAddress = 0 ; _muxPort = 0 ; _classPtr = new CLASSNAME ( port ); _next = NULL ; _logSense = new bool [ SENSE_COUNT + 1 ]; for ( size_t i = 0 ; i <= SENSE_COUNT ; i ++ ) _logSense [ i ] = true ; _customInitializePtr = NULL ; _shortDistanceMode = true ; } _shortDistanceMode records or indicates whether the sensor is in short or long distance mode. Why did we do it this way? Couldn't we have used a BOOL configuration item for it instead? Yes, we could have done it that way, but, as we explained above: The user would have had to select the distance mode setting Then enter a valid BOOL (0 or 1) The code in setSetting would have had to validate the choice before applying it By using two NONE choices, and storing the choice in _shortDistanceMode , we both make things easier for the user and simplify the code.","title":"initializeSensor"},{"location":"new_sensor/#getsensename","text":"getSenseName returns the name of each sense as const char * as it will appear in loggingMenu . The number of case statements must match SENSE_COUNT . Adapt the template code to match the number of senses for the new sensor; add or remove case statements as necessary. // Return the name of the name of the specified sense. ===> Adapt this to match the sensor type <=== const char * getSenseName ( uint8_t sense ) { switch ( sense ) { case 0 : return ( \"Pressure (Pa)\" ); break ; case 1 : return ( \"Temperature (C)\" ); break ; case 2 : return ( \"Humidity (%)\" ); break ; default : return ( NULL ); break ; } return ( NULL ); }","title":"getSenseName"},{"location":"new_sensor/#getsensereading","text":"getSenseReading is the method which calls the appropriate 'read' method for the selected sense . It is called by getSensorReadings . getSenseReading calls the Arduino Library method to read that sense and converts the reading into text format: // Return the specified sense reading as text. ===> Adapt this to match the sensor type <=== bool getSenseReading ( uint8_t sense , char * reading ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( sense ) { case 0 : _sprintf . _dtostrf (( double ) device -> readFloatPressure (), reading ); // Get the pressure return ( true ); break ; case 1 : _sprintf . _dtostrf (( double ) device -> readTempC (), reading ); // Get the temperature return ( true ); break ; case 2 : _sprintf . _dtostrf (( double ) device -> readFloatHumidity (), reading ); // Get the humidity return ( true ); break ; default : return ( false ); break ; } return ( false ); } Again, the number of case statements must match SENSE_COUNT . And, of course, the order of the case statements must be the same as getSenseName . Looking closely at the code for the Pressure (sense 0): _sprintf._dtostrf((double)device->readFloatPressure(), reading); The code is: Calling the Arduino Library readFloatPressure() method, using the _classPtr The result is being cast to double _sprintf._dtostrf is a helper function from the SFE_QUAD_Sensors_sprintf class which converts the double to text sprintf is not supported correctly on all platforms (Artemis / Apollo3 especially) so we added the helper method to the sensor class to ensure doubles are always converted to text correctly The text is copied into the char array reading If you like exponent-format , there is an additional helper function named _sprintf._etoa which will convert a double to exponent-format text. getSensorReadings pieces the text readings together in CSV format and retruns them in readings . If the sense methods return an integer (instead of float or double), then getSensorReadings does use sprintf to print the reading as text: // Return the specified sense reading as text. ===> Adapt this to match the sensor type <=== bool getSenseReading ( uint8_t sense , char * reading ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( sense ) { case 0 : sprintf ( reading , \"%d\" , device -> getDistance ()); return ( true ); break ; case 1 : sprintf ( reading , \"%d\" , device -> getRangeStatus ()); return ( true ); break ; case 2 : sprintf ( reading , \"%d\" , device -> getSignalRate ()); return ( true ); break ; default : return ( false ); break ; } return ( false ); }","title":"getSenseReading"},{"location":"new_sensor/#getsettingname","text":"Simple sensors, like the BME280, have no settings or configuration items. getSettingName simply returns NULL . // Return the name of the name of the specified setting. ===> Adapt this to match the sensor type <=== const char * getSettingName ( uint8_t setting ) { switch ( setting ) { default : return ( NULL ); break ; } return ( NULL ); } For the VL53L1X, getSettingName returns the name of each setting as it will appear in settingMenu : // Return the name of the name of the specified setting. ===> Adapt this to match the sensor type <=== const char * getSettingName ( uint8_t setting ) { switch ( setting ) { case 0 : return ( \"Distance Mode: Short\" ); break ; case 1 : return ( \"Distance Mode: Long\" ); break ; case 2 : return ( \"Intermeasurement Period\" ); break ; case 3 : return ( \"Crosstalk\" ); break ; case 4 : return ( \"Offset\" ); break ; default : return ( NULL ); break ; } return ( NULL ); } The number of case statements must match SETTING_COUNT .","title":"getSettingName"},{"location":"new_sensor/#getsettingtype","text":"getSettingType returns the SFE_QUAD_Sensor_Setting_Type_e data type for the setting. If the sensor has no settings ( SETTING_COUNT is zero), then getSettingType simply returns false: // Return the type of the specified setting. ===> Adapt this to match the sensor type <=== bool getSettingType ( uint8_t setting , SFE_QUAD_Sensor_Setting_Type_e * type ) { switch ( setting ) { default : return ( false ); break ; } return ( true ); } But if there are settings, it returns the data type which matches the type required by the Arduino Library setting method: // Return the type of the specified setting. ===> Adapt this to match the sensor type <=== bool getSettingType ( uint8_t setting , SFE_QUAD_Sensor_Setting_Type_e * type ) { switch ( setting ) { case 0 : case 1 : * type = SFE_QUAD_SETTING_TYPE_NONE ; break ; case 2 : case 3 : case 4 : * type = SFE_QUAD_SETTING_TYPE_UINT16_T ; break ; default : return ( false ); break ; } return ( true ); } The SFE_QUAD_Sensor_Setting_Type_e setting types are: SFE_QUAD_SETTING_TYPE_NONE SFE_QUAD_SETTING_TYPE_BOOL SFE_QUAD_SETTING_TYPE_FLOAT SFE_QUAD_SETTING_TYPE_DOUBLE SFE_QUAD_SETTING_TYPE_INT SFE_QUAD_SETTING_TYPE_UINT8_T SFE_QUAD_SETTING_TYPE_UINT16_T SFE_QUAD_SETTING_TYPE_UINT32_T All except NONE are self explanatory. If the Arduino Library setting method requires an int then set *type to SFE_QUAD_SETTING_TYPE_INT . Etc.. If the setting type is anything other than NONE , the settingMenu will call getSettingValueDouble and cast the result to the appropriate type before calling setSetting . The NONE type has no value, it simply causes the menu to do something when that menu option is selected. Looking at the code above, the NONE type is used for settings 0 and 1: \"Distance Mode: Short\" and \"Distance Mode: Long\". The matching code in setSetting then does something without needing a value from getSettingValueDouble . For the other three cases, a uint16_t will be passed to setSetting since that is what the Arduino Library methods require.","title":"getSettingType"},{"location":"new_sensor/#setsetting","text":"If the sensor has no settings ( SETTING_COUNT is zero), then setSetting simply returns false: // Set the specified setting. ===> Adapt this to match the sensor type <=== bool setSetting ( uint8_t setting , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( setting ) { default : return ( false ); break ; } return ( true ); } But for sensors like the VL53L1X, we do of course want setSettings to do something. Let's break it down into case 0-1 and 2-4: // Set the specified setting. ===> Adapt this to match the sensor type <=== bool setSetting ( uint8_t setting , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( setting ) { case 0 : device -> stopRanging (); _shortDistanceMode = true ; device -> setDistanceModeShort (); device -> startRanging (); break ; case 1 : device -> stopRanging (); _shortDistanceMode = false ; device -> setDistanceModeLong (); if ( device -> getIntermeasurementPeriod () < 140 ) device -> setIntermeasurementPeriod ( 140 ); device -> startRanging (); break ; For the two NONE types, settings 0 and 1: \"Distance Mode: Short\" and \"Distance Mode: Long\" the code in the case statement changes the sensor's distance mode accordingly. For case 0 (\"Distance Mode: Short\"), setSetting : Stops the sensor with its stopRanging() method Sets the member variable _shortDistanceMode to true so we have a record of the mode Sets the distance mode to short with setDistanceModeShort() (Re)starts the sensor with startRanging() The code for case 1 (\"Distance Mode: Long\") is similar, except: _shortDistanceMode is set to false For the long distance mode, the sensor's measurement period cannot be shorter than 140. The measurement period is increased if necessary For settings cases 2-4, the UINT16_T setting value is checked to make sure it is within the correct limits and is then passed to the Arduino Library set method: case 2 : device -> stopRanging (); if ( value -> UINT16_T < 20 ) value -> UINT16_T = 20 ; if ( ! _shortDistanceMode ) if ( value -> UINT16_T < 140 ) value -> UINT16_T = 140 ; if ( value -> UINT16_T > 1000 ) value -> UINT16_T = 1000 ; device -> setIntermeasurementPeriod ( value -> UINT16_T ); device -> startRanging (); break ; case 3 : device -> stopRanging (); if ( value -> UINT16_T > 4000 ) value -> UINT16_T = 4000 ; device -> setXTalk ( value -> UINT16_T ); device -> startRanging (); break ; case 4 : device -> stopRanging (); if ( value -> UINT16_T > 4000 ) value -> UINT16_T = 4000 ; device -> setOffset ( value -> UINT16_T ); device -> startRanging (); break ; default : return ( false ); break ; } return ( true ); }","title":"setSetting"},{"location":"new_sensor/#getconfigurationitemname","text":"The Configuration Item methods are almost identical to the Settings methods. Remember that Configuration Items are simply Settings which can be written to and read from storage. For the VL53L1X, \"Distance Mode: Short\" and \"Distance Mode: Long\" are combined into a BOOL for storage. But, other than that, the Configuration Items match the Settings. getConfigurationItemName returns a pointer to the name of each configuration item. The number of case statements must match CONFIGURATION_ITEM_COUNT . Some important points: Configuration Item names must not contain spaces Use underscores where necessary The names should be unique Keep the names short but meaningful Use abbreviations where possible These names occupy storage media space which - for EEPROM - can be limited Never use commas in the names The configurations are stored in CSV format // Return the name of the configuration item // Use underscores, not spaces const char * getConfigurationItemName ( uint8_t configItem ) { switch ( configItem ) { case 0 : return ( \"Dist_Mode\" ); break ; case 1 : return ( \"IM_Period\" ); break ; case 2 : return ( \"Xtalk\" ); break ; case 3 : return ( \"Offset\" ); break ; default : return ( NULL ); break ; } return ( NULL ); }","title":"getConfigurationItemName"},{"location":"new_sensor/#getconfigurationitemtype","text":"getConfigurationItemType is very similar to getSettingType . For the VL53L1X, the only difference is that the two distance mode NONE types have been integrated into a single BOOL // Return the type of the specified configuration item bool getConfigurationItemType ( uint8_t configItem , SFE_QUAD_Sensor_Setting_Type_e * type ) { switch ( configItem ) { case 0 : * type = SFE_QUAD_SETTING_TYPE_BOOL ; break ; case 1 : case 2 : case 3 : * type = SFE_QUAD_SETTING_TYPE_UINT16_T ; break ; default : return ( false ); break ; } return ( true ); }","title":"getConfigurationItemType"},{"location":"new_sensor/#getconfigurationitem","text":"getConfigurationItem calls the Arduino Library's get function for that configuration item. The value is returned in the appropriate field of the SFE_QUAD_Sensor_Every_Type_t . For the VL53L1X, the three uint16_t configuration items are returned in value->UINT16_T . The distance mode (config item 0) is simply read from the _shortDistanceMode member variable. We could have made use of the Library's getDistanceMode method and converted the return value (1 or 2) to bool . Doing it this way avoids an unnecessary I 2 C bus transaction. // Get (read) the sensor configuration item bool getConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( configItem ) { case 0 : value -> BOOL = _shortDistanceMode ; break ; case 1 : value -> UINT16_T = device -> getIntermeasurementPeriod (); break ; case 2 : value -> UINT16_T = device -> getXTalk (); break ; case 3 : value -> UINT16_T = device -> getOffset (); break ; default : return ( false ); break ; } return ( true ); }","title":"getConfigurationItem"},{"location":"new_sensor/#setconfigurationitem","text":"setConfigurationItem is very similar to setSetting . For the VL53L1X's distance mode, we use the value read from storage to update the _shortDistanceMode member variable. // Set (write) the sensor configuration item bool setConfigurationItem ( uint8_t configItem , SFE_QUAD_Sensor_Every_Type_t * value ) { CLASSNAME * device = ( CLASSNAME * ) _classPtr ; switch ( configItem ) { case 0 : _shortDistanceMode = value -> BOOL ; device -> stopRanging (); if ( _shortDistanceMode ) device -> setDistanceModeShort (); else device -> setDistanceModeLong (); device -> startRanging (); break ; case 1 : device -> stopRanging (); device -> setIntermeasurementPeriod ( value -> UINT16_T ); device -> startRanging (); break ; case 2 : device -> stopRanging (); device -> setXTalk ( value -> UINT16_T ); device -> startRanging (); break ; case 3 : device -> stopRanging (); device -> setOffset ( value -> UINT16_T ); device -> startRanging (); break ; default : return ( false ); break ; } return ( true ); }","title":"setConfigurationItem"},{"location":"new_sensor/#sfe_quad_sensorsh","text":"When adding a new sensor, src/SFE_QUAD_Sensors.h needs to be modified in three places:","title":"SFE_QUAD_Sensors.h"},{"location":"new_sensor/#include_sfe_quad_sensor_newsensorname","text":"Add a #define INCLUDE_SFE_QUAD_SENSOR_NewSensorName for the new sensor. This allows the user to select which sensors to include in the code build. By default, all sensors are included. Only including selected sensors speeds up the compilation time and reduces the amount of program memory used. However, SFE_QUAD_Sensors.h will be overwritten each time the library is updated. We have not (yet) been able to find a way of defining which sensors to include in the main .ino file. If you can think of a way of doing this - which works on all platforms - then please send us a Pull Request! For our fictitious FOO sensor, we would insert the #define in alphabetical order after CCS811 : // To select which sensors to include: // comment #define INCLUDE_SFE_QUAD_SENSOR_ALL // uncomment one or more #define INCLUDE_SFE_QUAD_SENSOR_ //#define INCLUDE_SFE_QUAD_SENSOR_ADS122C04 // Include individual sensors //#define INCLUDE_SFE_QUAD_SENSOR_AHT20 //#define INCLUDE_SFE_QUAD_SENSOR_BME280 //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5A //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5B //#define INCLUDE_SFE_QUAD_SENSOR_FOO The alphabetical ordering is not important, it just makes the list quicker to read.","title":"INCLUDE_SFE_QUAD_SENSOR_NewSensorName"},{"location":"new_sensor/#sfequadsensortype","text":"Scrolling ~halfway down SFE_QUAD_Sensors.h , you will find enum SFEQUADSensorType near the start of the class SFE_QUAD_Sensors . We need to add three lines for the new sensor. The ordering here is important as the enum SFEQUADSensorType is stored with each Configuration Item . The new sensor must be added to the end of the enum just before SFE_QUAD_Sensor_Number_Of_Sensors . Inserting it anywhere else will prevent existing saved configurations being used with the updated library. #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_VL53L1X) Sensor_VL53L1X , #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) Sensor_FOO , #endif SFE_QUAD_Sensor_Number_Of_Sensors // Must be last. <=== Add new sensors _above this line_ to preserve the existing enum values }; However, if you look closely at enum SFEQUADSensorType , you will see that the MS8607 appears before the MS5637 . #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_MS8607) // MS8607 must be before MS5637 (otherwise MS8607 will appear as a MS5637) Sensor_MS8607 , #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_MS5637) Sensor_MS5637 , #endif This is because the MS8607 is essentially a MS5637 with an additional built-in humidity sensor (with its own I 2 C address). The MS8607 must be detected before the MS5637 otherwise it will appear as a MS5637 and a MS8607. detectSensors contains some additional code to prevent the re-detection of an MS8607 as a MS5637. There may be similar cases where it is necessary to detect sensors in a particular order and for the new sensor to be inserted part-way through enum SFEQUADSensorType . If that happens, and you are sending us a Pull Request, please make this clear in the notes. We may still be able to merge your Pull Request, but we will need to make everyone aware that the new version is not backward-compatible with saved configurations from previous versions.","title":"SFEQUADSensorType"},{"location":"new_sensor/#sensorfactory","text":"We need to add the new sensor to the sensorFactory . This is the method which returns a new object of the requested sensor class. The order here is not important. Insert the new sensor alphabetically (unless there is a good reason not to): #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_CCS811_5B) if ( type == Sensor_CCS811_5B ) return new SFE_QUAD_Sensor_CCS811_5B ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) if ( type == Sensor_FOO ) return new SFE_QUAD_Sensor_FOO ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_LPS25HB) if ( type == Sensor_LPS25HB ) return new SFE_QUAD_Sensor_LPS25HB ; #endif","title":"sensorFactory"},{"location":"new_sensor/#deletesensor","text":"The final change to SFE_QUAD_Sensors.h is to add the new sensor to the deleteSensor . This is the method which deletes the sensor in a safe way, casting sensor to the correct class. The order here is not important. Insert the new sensor alphabetically (unless there is a good reason not to): #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_CCS811_5B) if ( type == Sensor_CCS811_5B ) delete ( SFE_QUAD_Sensor_CCS811_5B * ) sensor ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) if ( type == Sensor_FOO ) delete ( SFE_QUAD_Sensor_FOO * ) sensor ; #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_LPS25HB) if ( type == Sensor_LPS25HB ) delete ( SFE_QUAD_Sensor_LPS25HB * ) sensor ; #endif","title":"deleteSensor"},{"location":"new_sensor/#sfe_quad_headersh","text":"When adding a new sensor, src/SFE_QUAD_Headers.h needs to be modified to include the header file for the new sensor. The order here is not important. Insert the new sensor alphabetically (unless there is a good reason not to): #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_CCS811_5B) #include \"src/SFE_QUAD_Sensor_CCS811_5B.h\" #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_FOO) #include \"src/SFE_QUAD_Sensor_FOO.h\" #endif #if defined(INCLUDE_SFE_QUAD_SENSOR_ALL) || defined(INCLUDE_SFE_QUAD_SENSOR_LPS25HB) #include \"src/SFE_QUAD_Sensor_LPS25HB.h\" #endif","title":"SFE_QUAD_Headers.h"},{"location":"new_sensor/#githubworkflowscompile-sketchyml","text":"The final change is to update .github/workflows/compile-sketch.yml to include the new sensor's Arduino Library. Any changes to the sensor's Arduino Library are automatically merged into the copy in this library. That way, this library stays up to date with any and all changes to the individual Arduino Libraries. The entry for our fictitious FOO sensor would be something like: - name : Update FOO run : | cd . / src / src / mkdir - p FOO cd FOO curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.cpp You need to include the full raw.githubusercontent.com address for the library files: Navigate to the Arduino Library on GitHub Navigate to the src sub-folder Open the .h file Click the RAW button to view the file's raw content Copy and paste the address from your browser into compile-sketch.yml Repeat for the .cpp file If the Arduino Library contains more than the standard .h and .cpp files, include those too. E.g. looking at the SGP40: - name : Update SGP40 run : | cd . / src / src / mkdir - p SGP40 cd SGP40 curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/SparkFun_SGP40_Arduino_Library.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/SparkFun_SGP40_Arduino_Library.cpp curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/sensirion_arch_config.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/sensirion_voc_algorithm.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_SGP40_Arduino_Library/main/src/sensirion_voc_algorithm.c Finally, you need to check how the .cpp file includes its .h file. In Arduino examples, you will often see files included like this: #include <SparkFun_FOO_Arduino_Library.h> The less-than and greater-than tell the Arduino IDE compiler to search its PATH for SparkFun_FOO_Arduino_Library.h . SparkFun_FOO_Arduino_Library.h will normally be in a \\library sub-folder. For this library, we want to ensure the copy of the Arduino Library in the src\\src sub-folder is used, not the copy from the IDE PATH . Look inside the .cpp file. If you see: #include <SparkFun_FOO_Arduino_Library.h> then you need to include one extra line in compile-sketch.yml so that the less-than and greater-than are replaced automatically with double-quotes: - name : Update FOO run : | cd . / src / src / mkdir - p FOO cd FOO curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.h curl - O https : //raw.githubusercontent.com/sparkfun/SparkFun_FOO_Arduino_Library/main/src/SparkFun_FOO_Arduino_Library.cpp # SparkFun_FOO_Arduino_Library.cpp uses #include <SparkFun_FOO_Arduino_Library.h>. We need to replace the < and > with double quotes sed - i ' s /< SparkFun_FOO_Arduino_Library . h >/ '\\\"' SparkFun_FOO_Arduino_Library . h '\\\"' / g ' SparkFun_FOO_Arduino_Library . cpp","title":".github/workflows/compile-sketch.yml"},{"location":"software/","text":"Software Setup Installation The SparkFun Qwiic Universal Auto-Detect library is available within in the Arduino library manager, which is launched via the Sketch > Include Libraries > Manage Libraries \u2026 menu option in the Arduino IDE. Just search for SparkFun Qwiic Universal Note This guide assumes you are using the latest version of the Arduino IDE on your desktop. The following resources available at SparkFun provide the details on setting up and configuring Arduino to use this library. Installing the Arduino IDE Installing an Arduino Library Installing Board Definitions in the Arduino IDE General Use Pattern The SparkFun Qwiic Universal Auto-Detect library includes a comprehensive set of examples which show, step by step, how to use the library and create the correct SFE_QUAD_Sensors object for your application. The examples are available from the Examples menu of the Arduino IDE, and in the examples folder of this repository. For a detailed description of the examples, please see the Examples section of the documentation. We recommend starting with the documentation for Example1 as that demonstrates how to create and use a SFE_QUAD_Sensors__SD object in full detail. The later examples build upon Example1 and show how to use: SFE_QUAD_Sensors__SdFat , SFE_QUAD_Sensors__LittleFS , and SFE_QUAD_Sensors__EEPROM .","title":"Software Setup"},{"location":"software/#software-setup","text":"","title":"Software Setup"},{"location":"software/#installation","text":"The SparkFun Qwiic Universal Auto-Detect library is available within in the Arduino library manager, which is launched via the Sketch > Include Libraries > Manage Libraries \u2026 menu option in the Arduino IDE. Just search for SparkFun Qwiic Universal Note This guide assumes you are using the latest version of the Arduino IDE on your desktop. The following resources available at SparkFun provide the details on setting up and configuring Arduino to use this library. Installing the Arduino IDE Installing an Arduino Library Installing Board Definitions in the Arduino IDE","title":"Installation"},{"location":"software/#general-use-pattern","text":"The SparkFun Qwiic Universal Auto-Detect library includes a comprehensive set of examples which show, step by step, how to use the library and create the correct SFE_QUAD_Sensors object for your application. The examples are available from the Examples menu of the Arduino IDE, and in the examples folder of this repository. For a detailed description of the examples, please see the Examples section of the documentation. We recommend starting with the documentation for Example1 as that demonstrates how to create and use a SFE_QUAD_Sensors__SD object in full detail. The later examples build upon Example1 and show how to use: SFE_QUAD_Sensors__SdFat , SFE_QUAD_Sensors__LittleFS , and SFE_QUAD_Sensors__EEPROM .","title":"General Use Pattern"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/","text":"Example 1 - ESP32 Thing Plus C - Using SD for setting storage A simple example to show the basic setup and use of SparkFun Qwiic Universal Auto-Detect. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms. Key Features Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Writing the settings to microSD card using the standard Arduino SD library Reading the settings back from microSD card and applying them Later examples show how to store the sensor settings in EEPROM and LittleFS. Setup After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header files for SD and this library: #include <SD.h> // Include SD.h to enable support for SFE_QUAD_Sensors__SD. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect The next step is to declare the object for the SparkFun Qwiic Universal Auto-Detect. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the setup() or loop() functions. Select one of the following classes: Class Description SFE_QUAD_Sensors This is the core Sensors class - with no built-in support for writing and reading the sensor and menu configuration SFE_QUAD_Sensors__SD This class adds support for storing the sensor and menu configuration using the Arduino SD library SFE_QUAD_Sensors__SdFat This class adds support for storing the sensor and menu configuration using Bill Greiman's SdFat library - with support for FAT16, FAT32 and exFAT SFE_QUAD_Sensors__LittleFS This class adds support for storing the sensor and menu configuration in memory using LittleFS. ESP32 boards - and others - support LittleFS SFE_QUAD_Sensors__EEPROM This class adds support for storing the sensor and menu configuration in EEPROM. Artemis boards - and others - support EEPROM SFE_QUAD_Sensors__EEPROM (SAMD) This class adds support for storing the sensor and menu configuration in SAMD memory using FlashAsEEPROM_SAMD. You can use this on SAMD21 and SAMD51 boards For this example, the SFE_QUAD_Sensors__SD class is used. The sensor configuration will be stored on SD card using the standard Arduino SD library. SFE_QUAD_Sensors__SD mySensors ; The later examples show how to use the other Sensors classes. E.g. if you wanted to use the SFE_QUAD_Sensors__EEPROM class for SAMD , the code becomes: #include <FlashAsEEPROM_SAMD.h> // Include FlashAsEEPROM_SAMD.h to enable support for SFE_QUAD_Sensors__EEPROM on SAMD platforms. Do this before #include \"SFE_QUAD_Sensors__EEPROM.h\" #include \"SFE_QUAD_Sensors__EEPROM.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect SFE_QUAD_Sensors__EEPROM mySensors ; Initialization In the setup() function of this sketch, we need to do several things to: Start Wire (I 2 C) communication Tell the QUAD object which Wire port to use Tell the QUAD object which Serial port to use for the menus and to display the sensor readings Detect which sensors are attached Initialize the sensors Begin the microSD storage, so we can later write and read the settings to and from microSD card Set up the menu Display which sensors have been found and what the sense names are: A sensor can have multiple senses. E.g. a MS8607 sensor has three senses: Pressure, Temperature and Humidity You can tell the QUAD object which senses to enable through the menus. For the MS8607, the code can read: none, one, two or all three senses void setup () { delay ( 1000 ); //Give the sensors time to power on Serial . begin ( 115200 ); Serial . println ( F ( \"SparkFun Qwiic Universal Auto-Detect Example\" )); Wire . begin (); // Begin the Wire port at the default speed (usually 100kHz) mySensors . setWirePort ( Wire ); // Tell the class which Wire port to use //mySensors.enableDebugging(Serial); // Uncomment this line to enable debug messages on Serial mySensors . setMenuPort ( Serial ); // Use Serial for the menus mySensors . detectSensors (); // Detect which sensors are connected mySensors . beginSensors (); // Begin all the sensors mySensors . initializeSensors (); // Initialize all the sensors with the default settings if ( ! mySensors . beginStorage ( CS , \"/Config.csv\" ) // Begin the SD storage: CS is the chip select pin; \"/config.csv\" is the file which holds the configuration { Serial . println ( F ( \"beginStorage failed! You will not be able to write or read the sensor configuration...\" )); } Menu Set-Up One of the fantastic things about SparkFun Qwiic Universal Auto-Detect is that it has built-in support for menus. The logging and sensor settings menus are built in to the SFE_QUAD_Sensors object and can be opened with a single call. But it gets even better! SFE_QUAD_Sensors contains a SFE_QUAD_Menu object called theMenu which allows you to create your own menu and sub-menus quickly and easily. Each menu item can be: Menu Item E.g. SFE_QUAD_Menu_Variable_Type_e A simple line of text The name of the menu SFE_QUAD_MENU_VARIABLE_TYPE_NONE A link to a sub-menu A WiFi settings sub-menu SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START A link to a piece of code Code which is called when you select that menu option SFE_QUAD_MENU_VARIABLE_TYPE_CODE A text variable A WiFi SSID or password SFE_QUAD_MENU_VARIABLE_TYPE_TEXT bool data A menu setting which can be toggled true/false SFE_QUAD_MENU_VARIABLE_TYPE_BOOL float or double data A battery voltage threshold E.g. SFE_QUAD_MENU_VARIABLE_TYPE_FLOAT signed or unsigned integer data A logging interval E.g. SFE_QUAD_MENU_VARIABLE_TYPE_ULONG The menu object has built-in methods which will write and read the menu settings to and from EEPROM, LittleFS or SD. Say you want to be able to set your WiFi SSID within the menu and have it saved in EEPROM? SparkFun Qwiic Universal Auto-Detect will let you do that with two lines of code! The later examples show how to create more complex menus. However, in this example we keep things simple. The menu here allows you to: Open the sensor logging menu Open the sensor settings menu Write the sensor configuration to SD Read the sensor configuration from SD // Create the menu mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"====\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"Open the sensor logging menu\" , openLoggingMenu ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"Open the sensor settings menu\" , openSettingMenu ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"Write the sensor configuration to SD\" , writeConfig ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"Read the sensor configuration from SD\" , readConfig ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); while ( mySensors . theMenu . _menuPort -> available ()) // Clear the menu serial buffer mySensors . theMenu . _menuPort -> read (); Serial . println ( F ( \"Press any key to open the menu\" )); You can use the Arduino IDE Serial Monitor, or a dedicated terminal-emulator like Tera Term, to access the menus. Open your COM port at 115200 baud and press a key to open the menu: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: The code called by the menu is described below . Sensor Names The sensor names helper text is generated by calling getSensorNames(); . The names of all of the attached sensors are returned in mySensors.readings , strung together in CSV (Comma Separated Value) format. mySensors . getSensorNames (); // Print the sensor names helper text - show which sensors have been found Serial . println ( mySensors . readings ); The sensor name is made up from the following (separated by underscores): The sensor type (e.g. MS8607) Its I 2 C address If the sensor is connected through a Qwiic Mux , the name also contains: The Mux I 2 C address The number of the Mux port which the sensor is attached to If a Mux is not being used, the Mux address and port are both shown as 0 Sense Names A sensor can have one or more senses. E.g. a MS8607 sensor has three senses: Pressure, Temperature and Humidity. The sense names helper text is generated by calling getSenseNames(); . It contains the name of each enabled sense in CSV format. If a sense has been disabled via the loggingMenu , its name will be missing. mySensors . getSenseNames (); // Print the sense names helper text - show which senses are being read Serial . println ( mySensors . readings ); } E.g. if a single MS8607 is attached, not using a mux, and all three senses are enabled, the sensor and sense names will be shown as: MS8607_64_0_0,MS8607_64_0_0,MS8607_64_0_0 Pressure (mbar),Temperature (C),Humidity (%) The sensor name is the following (separated by underscores): MS8607 The I 2 C address: 64 decimal (which is 0x40 hexadecimal (unshifted)) No mux (address is shown as zero) No mux port (port number is shown as zero) The sense names are self-explanatory. Again, they are Comma-Separated. If two MS8607s are attached, using a Qwiic Mux , the sensor and sense helper text could be: MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_1,MS8607_64_113_1,MS8607_64_113_1 Pressure (mbar),Temperature (C),Humidity (%),Pressure (mbar),Temperature (C),Humidity (%) The sensor names indicate that the two MS8607s are connected: Using a mux with address 113 (which is 0x71 hexadecimal (unshifted)) Using ports 0 and 1 Sensor Readings The loop() reads the sense values from the attached sensors and prints them to Serial. It also checks if the user has pressed a key - to open the menu: void loop () { mySensors . getSensorReadings (); // Read all enabled senses from all enabled sensors Serial . println ( mySensors . readings ); if ( mySensors . theMenu . _menuPort -> available ()) // Has the user pressed a key? { mySensors . theMenu . openMenu (); // If so, open the menu } delay ( 500 ); } The getSensorReadings(); method reads the sensor sense values and copies them into readings which is a char array inside the mySensors object. You can print the readings with Serial.println(mySensors.readings); The delay(500); sets the read rate: the sensors are read every 500ms (twice per second). The later examples show how to set the read rate using the built-in configurable menus. The Menus The code which is called by the menu is included at the end of the example. It is very simple too: void openLoggingMenu ( void ) { mySensors . loggingMenu (); mySensors . getSensorNames (); // Print the sensor names helper - it may have changed Serial . println ( mySensors . readings ); mySensors . getSenseNames (); // Print the sense names helper - it may have changed Serial . println ( mySensors . readings ); } void openSettingMenu ( void ) { mySensors . settingMenu (); } void writeConfig ( void ) { mySensors . getSensorAndMenuConfiguration (); mySensors . writeConfigurationToStorage ( false ); // Set append to false - overwrite the configuration } void readConfig ( void ) { mySensors . readConfigurationFromStorage (); mySensors . applySensorAndMenuConfiguration (); } The Logging Menu If you select Open the sensor logging menu (Option 1), the built-in loggingMenu() method is called and the logging menu is opened. The logging menu allows the user to configure which of the connected sensors and senses are enabled (selected) for 'logging'. (This example does not actually log any data, the sense readings are only printed to Serial. The later examples show how to actually log the data.) The menu automatically configures itself depending on which sensors are connected. For each sensor, there is an option to disable all of its senses if required. Extra lines in the menu allow individual senses to be enabled or disabled. E.g. if only a single MS8607 is attached, the menu will appear as: Sensor MS8607 at address 0x40 1 : Log this sensor : Yes 2 : Log Pressure (mbar) : Yes 3 : Log Temperature (C) : Yes 4 : Log Humidity (%) : Yes Enter a number to toggle the setting, or enter 0 to exit: Selecting option 1 will disable the sensor completely: Sensor MS8607 at address 0x40 1 : Log this sensor : No Enter a number to toggle the setting, or enter 0 to exit: Selecting option 1 again, followed by option 3, results in the Temperature sense being disabled: Sensor MS8607 at address 0x40 1 : Log this sensor : Yes 2 : Log Pressure (mbar) : Yes 3 : Log Temperature (C) : No 4 : Log Humidity (%) : Yes Enter a number to toggle the setting, or enter 0 to exit: The helper text and readings become: MS8607_64_0_0,MS8607_64_0_0 Pressure (mbar),Humidity (%) 1011.020,41.237 1010.980,41.237 We can see that only Pressure and Humidity are enabled. The default precision (number of decimal places) is 3. You can adjust the precision by calling the method _sprintf.setPrecision . E.g. to change the precision to 5 decimal places, insert this before the mySensors.detectSensors(); : mySensors._sprintf.setPrecision(5); There is a helper method _sprintf.expStrToDouble which you can use to convert exponent-format text into a double. If two MS8607s are connected via a Mux, the helper text, readings and menus become: MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_1,MS8607_64_113_1,MS8607_64_113_1 Pressure (mbar),Temperature (C),Humidity (%),Pressure (mbar),Temperature (C),Humidity (%) 1010.010,20.540,46.127,1009.670,20.670,41.237 1010.000,20.559,46.127,1009.700,20.690,41.237 Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 1 Sensor MS8607 at address 0x40, mux address 0x71 port 0 1 : Log this sensor : Yes 2 : Log Pressure (mbar) : Yes 3 : Log Temperature (C) : Yes 4 : Log Humidity (%) : Yes Sensor MS8607 at address 0x40, mux address 0x71 port 1 5 : Log this sensor : Yes 6 : Log Pressure (mbar) : Yes 7 : Log Temperature (C) : Yes 8 : Log Humidity (%) : Yes Enter a number to toggle the setting, or enter 0 to exit: The Setting Menu If you select Open the sensor settings menu (Option 2), the built-in settingMenu() method is called and the sensor settings menu is opened. The settings menu allows the user to configure the sensor settings - if it has any. The settings can be stored in EEPROM, LittleFS or on SD card. A good example of how to use the settings is with the NAU7802 load cell sensor. To use the load cell sensor, we need to calibrate it by setting its zero offset and calibration factor. If we connect a single NAU7802, the readings appear initially as: SparkFun Qwiic Universal Auto-Detect Example Press any key to open the menu NAU7802_42_0_0 Weight nan nan nan nan means Not A Number. The NAU7802 is retuning invalid data as it has not been calibrated. If we open the settings menu we see: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 2 Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: With no weight on the load cell, selecting option 1 sets the zero offset. Place (e.g.) a 100g weight on the load cell, select option 2 and enter the value 100.00 when instructed: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 2 Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: Set Zero Offset was successful Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: Enter a floating point value (or wait 10 seconds to abort): Set Calibration Factor was successful Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: settingMenu: exiting... Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 100.566 The load cell has been successfully calibrated. The first reading is 100.566g. Another of the fantastic things about SparkFun Qwiic Universal Auto-Detect is that we can now store that calibration to SD card by selecting Write the sensor configuration to SD (Option 3) from the main menu. Next time we power up the system, we can restore the calibration by selecting Read the sensor configuration from SD (Option 4): 150764.48 150819.95 150785.34 150745.64 Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 4 Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 111.378 109.253 114.403 Storing the configuration was not possible with OpenLog Artemis . We are very pleased that SparkFun Qwiic Universal Auto-Detect makes it so easy! You can load the settings by default by calling readConfig(); in your setup() . The stored configuration includes which mux port the sensor is connected to. So, you can: Connect multiple NAU7802s via a Qwiic Mux Calibrate all of the sensors using the menus Store the configuration for all the sensors Restore the configuration for all the sensors So long as you do not change which mux port each sensor is connected to, the correct configuration will be restored each time! Menu Timeout If the 10 second menu timeout is too short for you, you can change it to (e.g.) 20 seconds by calling: mySensors.theMenu.setMenuTimeout(20000); The menu timeout is set in milliseconds.","title":"Example 1 - Thing Plus C"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#example-1-esp32-thing-plus-c-using-sd-for-setting-storage","text":"A simple example to show the basic setup and use of SparkFun Qwiic Universal Auto-Detect. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms.","title":"Example 1 - ESP32 Thing Plus C - Using SD for setting storage"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#key-features","text":"Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Writing the settings to microSD card using the standard Arduino SD library Reading the settings back from microSD card and applying them Later examples show how to store the sensor settings in EEPROM and LittleFS.","title":"Key Features"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#setup","text":"After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header files for SD and this library: #include <SD.h> // Include SD.h to enable support for SFE_QUAD_Sensors__SD. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect The next step is to declare the object for the SparkFun Qwiic Universal Auto-Detect. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the setup() or loop() functions. Select one of the following classes: Class Description SFE_QUAD_Sensors This is the core Sensors class - with no built-in support for writing and reading the sensor and menu configuration SFE_QUAD_Sensors__SD This class adds support for storing the sensor and menu configuration using the Arduino SD library SFE_QUAD_Sensors__SdFat This class adds support for storing the sensor and menu configuration using Bill Greiman's SdFat library - with support for FAT16, FAT32 and exFAT SFE_QUAD_Sensors__LittleFS This class adds support for storing the sensor and menu configuration in memory using LittleFS. ESP32 boards - and others - support LittleFS SFE_QUAD_Sensors__EEPROM This class adds support for storing the sensor and menu configuration in EEPROM. Artemis boards - and others - support EEPROM SFE_QUAD_Sensors__EEPROM (SAMD) This class adds support for storing the sensor and menu configuration in SAMD memory using FlashAsEEPROM_SAMD. You can use this on SAMD21 and SAMD51 boards For this example, the SFE_QUAD_Sensors__SD class is used. The sensor configuration will be stored on SD card using the standard Arduino SD library. SFE_QUAD_Sensors__SD mySensors ; The later examples show how to use the other Sensors classes. E.g. if you wanted to use the SFE_QUAD_Sensors__EEPROM class for SAMD , the code becomes: #include <FlashAsEEPROM_SAMD.h> // Include FlashAsEEPROM_SAMD.h to enable support for SFE_QUAD_Sensors__EEPROM on SAMD platforms. Do this before #include \"SFE_QUAD_Sensors__EEPROM.h\" #include \"SFE_QUAD_Sensors__EEPROM.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect SFE_QUAD_Sensors__EEPROM mySensors ;","title":"Setup"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#initialization","text":"In the setup() function of this sketch, we need to do several things to: Start Wire (I 2 C) communication Tell the QUAD object which Wire port to use Tell the QUAD object which Serial port to use for the menus and to display the sensor readings Detect which sensors are attached Initialize the sensors Begin the microSD storage, so we can later write and read the settings to and from microSD card Set up the menu Display which sensors have been found and what the sense names are: A sensor can have multiple senses. E.g. a MS8607 sensor has three senses: Pressure, Temperature and Humidity You can tell the QUAD object which senses to enable through the menus. For the MS8607, the code can read: none, one, two or all three senses void setup () { delay ( 1000 ); //Give the sensors time to power on Serial . begin ( 115200 ); Serial . println ( F ( \"SparkFun Qwiic Universal Auto-Detect Example\" )); Wire . begin (); // Begin the Wire port at the default speed (usually 100kHz) mySensors . setWirePort ( Wire ); // Tell the class which Wire port to use //mySensors.enableDebugging(Serial); // Uncomment this line to enable debug messages on Serial mySensors . setMenuPort ( Serial ); // Use Serial for the menus mySensors . detectSensors (); // Detect which sensors are connected mySensors . beginSensors (); // Begin all the sensors mySensors . initializeSensors (); // Initialize all the sensors with the default settings if ( ! mySensors . beginStorage ( CS , \"/Config.csv\" ) // Begin the SD storage: CS is the chip select pin; \"/config.csv\" is the file which holds the configuration { Serial . println ( F ( \"beginStorage failed! You will not be able to write or read the sensor configuration...\" )); }","title":"Initialization"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#menu-set-up","text":"One of the fantastic things about SparkFun Qwiic Universal Auto-Detect is that it has built-in support for menus. The logging and sensor settings menus are built in to the SFE_QUAD_Sensors object and can be opened with a single call. But it gets even better! SFE_QUAD_Sensors contains a SFE_QUAD_Menu object called theMenu which allows you to create your own menu and sub-menus quickly and easily. Each menu item can be: Menu Item E.g. SFE_QUAD_Menu_Variable_Type_e A simple line of text The name of the menu SFE_QUAD_MENU_VARIABLE_TYPE_NONE A link to a sub-menu A WiFi settings sub-menu SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START A link to a piece of code Code which is called when you select that menu option SFE_QUAD_MENU_VARIABLE_TYPE_CODE A text variable A WiFi SSID or password SFE_QUAD_MENU_VARIABLE_TYPE_TEXT bool data A menu setting which can be toggled true/false SFE_QUAD_MENU_VARIABLE_TYPE_BOOL float or double data A battery voltage threshold E.g. SFE_QUAD_MENU_VARIABLE_TYPE_FLOAT signed or unsigned integer data A logging interval E.g. SFE_QUAD_MENU_VARIABLE_TYPE_ULONG The menu object has built-in methods which will write and read the menu settings to and from EEPROM, LittleFS or SD. Say you want to be able to set your WiFi SSID within the menu and have it saved in EEPROM? SparkFun Qwiic Universal Auto-Detect will let you do that with two lines of code! The later examples show how to create more complex menus. However, in this example we keep things simple. The menu here allows you to: Open the sensor logging menu Open the sensor settings menu Write the sensor configuration to SD Read the sensor configuration from SD // Create the menu mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"====\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"Open the sensor logging menu\" , openLoggingMenu ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"Open the sensor settings menu\" , openSettingMenu ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"Write the sensor configuration to SD\" , writeConfig ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"Read the sensor configuration from SD\" , readConfig ); // This is SFE_QUAD_MENU_VARIABLE_TYPE_CODE mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); while ( mySensors . theMenu . _menuPort -> available ()) // Clear the menu serial buffer mySensors . theMenu . _menuPort -> read (); Serial . println ( F ( \"Press any key to open the menu\" )); You can use the Arduino IDE Serial Monitor, or a dedicated terminal-emulator like Tera Term, to access the menus. Open your COM port at 115200 baud and press a key to open the menu: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: The code called by the menu is described below .","title":"Menu Set-Up"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#sensor-names","text":"The sensor names helper text is generated by calling getSensorNames(); . The names of all of the attached sensors are returned in mySensors.readings , strung together in CSV (Comma Separated Value) format. mySensors . getSensorNames (); // Print the sensor names helper text - show which sensors have been found Serial . println ( mySensors . readings ); The sensor name is made up from the following (separated by underscores): The sensor type (e.g. MS8607) Its I 2 C address If the sensor is connected through a Qwiic Mux , the name also contains: The Mux I 2 C address The number of the Mux port which the sensor is attached to If a Mux is not being used, the Mux address and port are both shown as 0","title":"Sensor Names"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#sense-names","text":"A sensor can have one or more senses. E.g. a MS8607 sensor has three senses: Pressure, Temperature and Humidity. The sense names helper text is generated by calling getSenseNames(); . It contains the name of each enabled sense in CSV format. If a sense has been disabled via the loggingMenu , its name will be missing. mySensors . getSenseNames (); // Print the sense names helper text - show which senses are being read Serial . println ( mySensors . readings ); } E.g. if a single MS8607 is attached, not using a mux, and all three senses are enabled, the sensor and sense names will be shown as: MS8607_64_0_0,MS8607_64_0_0,MS8607_64_0_0 Pressure (mbar),Temperature (C),Humidity (%) The sensor name is the following (separated by underscores): MS8607 The I 2 C address: 64 decimal (which is 0x40 hexadecimal (unshifted)) No mux (address is shown as zero) No mux port (port number is shown as zero) The sense names are self-explanatory. Again, they are Comma-Separated. If two MS8607s are attached, using a Qwiic Mux , the sensor and sense helper text could be: MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_1,MS8607_64_113_1,MS8607_64_113_1 Pressure (mbar),Temperature (C),Humidity (%),Pressure (mbar),Temperature (C),Humidity (%) The sensor names indicate that the two MS8607s are connected: Using a mux with address 113 (which is 0x71 hexadecimal (unshifted)) Using ports 0 and 1","title":"Sense Names"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#sensor-readings","text":"The loop() reads the sense values from the attached sensors and prints them to Serial. It also checks if the user has pressed a key - to open the menu: void loop () { mySensors . getSensorReadings (); // Read all enabled senses from all enabled sensors Serial . println ( mySensors . readings ); if ( mySensors . theMenu . _menuPort -> available ()) // Has the user pressed a key? { mySensors . theMenu . openMenu (); // If so, open the menu } delay ( 500 ); } The getSensorReadings(); method reads the sensor sense values and copies them into readings which is a char array inside the mySensors object. You can print the readings with Serial.println(mySensors.readings); The delay(500); sets the read rate: the sensors are read every 500ms (twice per second). The later examples show how to set the read rate using the built-in configurable menus.","title":"Sensor Readings"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#the-menus","text":"The code which is called by the menu is included at the end of the example. It is very simple too: void openLoggingMenu ( void ) { mySensors . loggingMenu (); mySensors . getSensorNames (); // Print the sensor names helper - it may have changed Serial . println ( mySensors . readings ); mySensors . getSenseNames (); // Print the sense names helper - it may have changed Serial . println ( mySensors . readings ); } void openSettingMenu ( void ) { mySensors . settingMenu (); } void writeConfig ( void ) { mySensors . getSensorAndMenuConfiguration (); mySensors . writeConfigurationToStorage ( false ); // Set append to false - overwrite the configuration } void readConfig ( void ) { mySensors . readConfigurationFromStorage (); mySensors . applySensorAndMenuConfiguration (); }","title":"The Menus"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#the-logging-menu","text":"If you select Open the sensor logging menu (Option 1), the built-in loggingMenu() method is called and the logging menu is opened. The logging menu allows the user to configure which of the connected sensors and senses are enabled (selected) for 'logging'. (This example does not actually log any data, the sense readings are only printed to Serial. The later examples show how to actually log the data.) The menu automatically configures itself depending on which sensors are connected. For each sensor, there is an option to disable all of its senses if required. Extra lines in the menu allow individual senses to be enabled or disabled. E.g. if only a single MS8607 is attached, the menu will appear as: Sensor MS8607 at address 0x40 1 : Log this sensor : Yes 2 : Log Pressure (mbar) : Yes 3 : Log Temperature (C) : Yes 4 : Log Humidity (%) : Yes Enter a number to toggle the setting, or enter 0 to exit: Selecting option 1 will disable the sensor completely: Sensor MS8607 at address 0x40 1 : Log this sensor : No Enter a number to toggle the setting, or enter 0 to exit: Selecting option 1 again, followed by option 3, results in the Temperature sense being disabled: Sensor MS8607 at address 0x40 1 : Log this sensor : Yes 2 : Log Pressure (mbar) : Yes 3 : Log Temperature (C) : No 4 : Log Humidity (%) : Yes Enter a number to toggle the setting, or enter 0 to exit: The helper text and readings become: MS8607_64_0_0,MS8607_64_0_0 Pressure (mbar),Humidity (%) 1011.020,41.237 1010.980,41.237 We can see that only Pressure and Humidity are enabled. The default precision (number of decimal places) is 3. You can adjust the precision by calling the method _sprintf.setPrecision . E.g. to change the precision to 5 decimal places, insert this before the mySensors.detectSensors(); : mySensors._sprintf.setPrecision(5); There is a helper method _sprintf.expStrToDouble which you can use to convert exponent-format text into a double. If two MS8607s are connected via a Mux, the helper text, readings and menus become: MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_0,MS8607_64_113_1,MS8607_64_113_1,MS8607_64_113_1 Pressure (mbar),Temperature (C),Humidity (%),Pressure (mbar),Temperature (C),Humidity (%) 1010.010,20.540,46.127,1009.670,20.670,41.237 1010.000,20.559,46.127,1009.700,20.690,41.237 Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 1 Sensor MS8607 at address 0x40, mux address 0x71 port 0 1 : Log this sensor : Yes 2 : Log Pressure (mbar) : Yes 3 : Log Temperature (C) : Yes 4 : Log Humidity (%) : Yes Sensor MS8607 at address 0x40, mux address 0x71 port 1 5 : Log this sensor : Yes 6 : Log Pressure (mbar) : Yes 7 : Log Temperature (C) : Yes 8 : Log Humidity (%) : Yes Enter a number to toggle the setting, or enter 0 to exit:","title":"The Logging Menu"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#the-setting-menu","text":"If you select Open the sensor settings menu (Option 2), the built-in settingMenu() method is called and the sensor settings menu is opened. The settings menu allows the user to configure the sensor settings - if it has any. The settings can be stored in EEPROM, LittleFS or on SD card. A good example of how to use the settings is with the NAU7802 load cell sensor. To use the load cell sensor, we need to calibrate it by setting its zero offset and calibration factor. If we connect a single NAU7802, the readings appear initially as: SparkFun Qwiic Universal Auto-Detect Example Press any key to open the menu NAU7802_42_0_0 Weight nan nan nan nan means Not A Number. The NAU7802 is retuning invalid data as it has not been calibrated. If we open the settings menu we see: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 2 Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: With no weight on the load cell, selecting option 1 sets the zero offset. Place (e.g.) a 100g weight on the load cell, select option 2 and enter the value 100.00 when instructed: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 2 Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: Set Zero Offset was successful Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: Enter a floating point value (or wait 10 seconds to abort): Set Calibration Factor was successful Sensor NAU7802 at address 0x2A 1 : Set Zero Offset 2 : Set Calibration Factor Enter a number to change the setting, or enter 0 to exit: settingMenu: exiting... Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 100.566 The load cell has been successfully calibrated. The first reading is 100.566g. Another of the fantastic things about SparkFun Qwiic Universal Auto-Detect is that we can now store that calibration to SD card by selecting Write the sensor configuration to SD (Option 3) from the main menu. Next time we power up the system, we can restore the calibration by selecting Read the sensor configuration from SD (Option 4): 150764.48 150819.95 150785.34 150745.64 Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 4 Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Write the sensor configuration to SD 4 : Read the sensor configuration from SD Enter a number, or enter 0 to exit: 111.378 109.253 114.403 Storing the configuration was not possible with OpenLog Artemis . We are very pleased that SparkFun Qwiic Universal Auto-Detect makes it so easy! You can load the settings by default by calling readConfig(); in your setup() . The stored configuration includes which mux port the sensor is connected to. So, you can: Connect multiple NAU7802s via a Qwiic Mux Calibrate all of the sensors using the menus Store the configuration for all the sensors Restore the configuration for all the sensors So long as you do not change which mux port each sensor is connected to, the correct configuration will be restored each time!","title":"The Setting Menu"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_01_Thing_Plus_C/#menu-timeout","text":"If the 10 second menu timeout is too short for you, you can change it to (e.g.) 20 seconds by calling: mySensors.theMenu.setMenuTimeout(20000); The menu timeout is set in milliseconds.","title":"Menu Timeout"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_02_ESP32_LittleFS/","text":"Example 2 - ESP32 LittleFS - Using LittleFS for setting storage Another simple example to show the basic setup and use of SparkFun Qwiic Universal Auto-Detect when using LittleFS to store the sensor configuration. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms. Key Features Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Writing the settings to LittleFS Reading the settings back from LittleFS and applying them This example is almost identical to Example1 . Please see the Example1 documentation for a full walk-through of the code. The only differences in this example are: Setup After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header files for LittleFS and this library: #include <LittleFS.h> // Include LittleFS.h to enable support for SFE_QUAD_Sensors__LittleFS. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect The next step is to declare the object for the SparkFun Qwiic Universal Auto-Detect. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the setup() or loop() functions. For this example, the SFE_QUAD_Sensors__LittleFS class is used. The sensor configuration will be stored in LittleFS. SFE_QUAD_Sensors__LittleFS mySensors ; Other examples show how to use the other Sensors classes: EEPROM and SD. Initialization Because we are using LittleFS to store the configuration, the call to beginStorage in setup() changes to: if ( ! mySensors . beginStorage ( \"/Config.csv\" ) // Begin the SD storage: \"/config.csv\" is the file which holds the configuration { Serial . println ( F ( \"beginStorage failed! You will not be able to write or read the sensor configuration...\" )); }","title":"Example 2 - ESP32 LittleFS"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_02_ESP32_LittleFS/#example-2-esp32-littlefs-using-littlefs-for-setting-storage","text":"Another simple example to show the basic setup and use of SparkFun Qwiic Universal Auto-Detect when using LittleFS to store the sensor configuration. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms.","title":"Example 2 - ESP32 LittleFS - Using LittleFS for setting storage"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_02_ESP32_LittleFS/#key-features","text":"Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Writing the settings to LittleFS Reading the settings back from LittleFS and applying them This example is almost identical to Example1 . Please see the Example1 documentation for a full walk-through of the code. The only differences in this example are:","title":"Key Features"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_02_ESP32_LittleFS/#setup","text":"After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header files for LittleFS and this library: #include <LittleFS.h> // Include LittleFS.h to enable support for SFE_QUAD_Sensors__LittleFS. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect The next step is to declare the object for the SparkFun Qwiic Universal Auto-Detect. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the setup() or loop() functions. For this example, the SFE_QUAD_Sensors__LittleFS class is used. The sensor configuration will be stored in LittleFS. SFE_QUAD_Sensors__LittleFS mySensors ; Other examples show how to use the other Sensors classes: EEPROM and SD.","title":"Setup"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_02_ESP32_LittleFS/#initialization","text":"Because we are using LittleFS to store the configuration, the call to beginStorage in setup() changes to: if ( ! mySensors . beginStorage ( \"/Config.csv\" ) // Begin the SD storage: \"/config.csv\" is the file which holds the configuration { Serial . println ( F ( \"beginStorage failed! You will not be able to write or read the sensor configuration...\" )); }","title":"Initialization"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_03_EEPROM/","text":"Example 3 - EEPROM - Using EEPROM for setting storage Another simple example to show the basic setup and use of SparkFun Qwiic Universal Auto-Detect when using EEPROM to store the sensor configuration. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms. Key Features Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Writing the settings to EEPROM Reading the settings back from EEPROM and applying them This example is almost identical to Example1 . Please see the Example1 documentation for a full walk-through of the code. The only differences in this example are: Setup After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header files for EEPROM and this library: #include <EEPROM.h> // Include EEPROM.h to enable support for SFE_QUAD_Sensors__EEPROM. Do this before #include \"SFE_QUAD_Sensors.h\" //#include <FlashAsEEPROM_SAMD.h> // Khoi Hoang's FlashStorage_SAMD works well too: http://librarymanager/All#FlashStorage_SAMD #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect If you are using SAMD21 or SAMD51, please comment the #include <EEPROM.h> and uncomment the #include <FlashAsEEPROM_SAMD.h> to use Khoi Hoang's FlashStorage_SAMD library. The next step is to declare the object for the SparkFun Qwiic Universal Auto-Detect. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the setup() or loop() functions. For this example, the SFE_QUAD_Sensors__EEPROM class is used. The sensor configuration will be stored in EEPROM. SFE_QUAD_Sensors__EEPROM mySensors ; Other examples show how to use the other Sensors classes: LittleFS and SD. Initialization Because we are using EEPROM to store the configuration, the call to beginStorage in setup() changes to: if ( ! mySensors . beginStorage ()) { Serial . println ( F ( \"beginStorage failed! You will not be able to write or read the sensor configuration...\" )); }","title":"Example 3 - EEPROM"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_03_EEPROM/#example-3-eeprom-using-eeprom-for-setting-storage","text":"Another simple example to show the basic setup and use of SparkFun Qwiic Universal Auto-Detect when using EEPROM to store the sensor configuration. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms.","title":"Example 3 - EEPROM - Using EEPROM for setting storage"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_03_EEPROM/#key-features","text":"Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Writing the settings to EEPROM Reading the settings back from EEPROM and applying them This example is almost identical to Example1 . Please see the Example1 documentation for a full walk-through of the code. The only differences in this example are:","title":"Key Features"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_03_EEPROM/#setup","text":"After installing this library in your local Arduino environment, begin with a standard Arduino sketch and include the header files for EEPROM and this library: #include <EEPROM.h> // Include EEPROM.h to enable support for SFE_QUAD_Sensors__EEPROM. Do this before #include \"SFE_QUAD_Sensors.h\" //#include <FlashAsEEPROM_SAMD.h> // Khoi Hoang's FlashStorage_SAMD works well too: http://librarymanager/All#FlashStorage_SAMD #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect If you are using SAMD21 or SAMD51, please comment the #include <EEPROM.h> and uncomment the #include <FlashAsEEPROM_SAMD.h> to use Khoi Hoang's FlashStorage_SAMD library. The next step is to declare the object for the SparkFun Qwiic Universal Auto-Detect. Like most Arduino sketches, this is done at a global scope (after the include file declaration), not within the setup() or loop() functions. For this example, the SFE_QUAD_Sensors__EEPROM class is used. The sensor configuration will be stored in EEPROM. SFE_QUAD_Sensors__EEPROM mySensors ; Other examples show how to use the other Sensors classes: LittleFS and SD.","title":"Setup"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_03_EEPROM/#initialization","text":"Because we are using EEPROM to store the configuration, the call to beginStorage in setup() changes to: if ( ! mySensors . beginStorage ()) { Serial . println ( F ( \"beginStorage failed! You will not be able to write or read the sensor configuration...\" )); }","title":"Initialization"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_04_Custom_Initialization/","text":"Example 4 - Custom Initialization - How to change the sensor initialization Another of the fantastic things about SparkFun Qwiic Universal Auto-Detect is that it will automatically initialize the sensors for you. Based on our experience with OpenLog Artemis , we have included initialization code for the sensors that require it. The code is applied when you call initializeSensors(); in setup() . But what if you want to initialize your sensor(s) differently? What do you do then? Do you need to edit the initialization code in this library - only to have your work overwritten when the library is updated? No! We have included a Custom Initialization feature to let you let you change the initialization safely and easily! In this example, we focus on the u-blox GNSS module. The initialization code inside this library looks like this: device -> setI2COutput ( COM_TYPE_UBX ); // Set the I2C port to output UBX only (turn off NMEA noise) device -> saveConfigSelective ( VAL_CFG_SUBSEC_IOPORT ); // Save (only) the communications port settings to flash and BBR device -> setAutoPVT ( true ); // Enable PVT at the navigation rate The code is doing three things which we (nearly) always need to do when communicating with a u-blox GNSS: We disable the NMEA protocol on the I2C port, leaving only UBX enabled We save the port configuration to battery-backed memory We tell the u-blox module to output its position, velocity and time (PVT) message at the standard 1Hz navigation rate The third thing prevents the u-blox GNSS library from stalling (blocking) while it waits for the next PVT message. setAutoPVT(true); causes the PVT messages to be generated periodically, and tells the library to return immediately using the data from the most recent PVT message instead of waiting for 'fresh' data to arrive. That way, you get your position immediately (even if it is slightly out of date). But what if you are always going to run the GNSS at 4Hz instead of the standard 1Hz? How do you tell the library to use your own custom initialization code? This is how: Custom Initializer At the start of the example, you will see the code for the custom initializer: // Define a custom initialization function for (e.g.) the u-blox GNSS // _____ You can use any name you like for the initializer. Use the same name when you call setCustomInitialize // / _____ This _must_ be uint8_t sensorAddress, TwoWire &port, void *_classPtr // | / // | | // | |--------------------^------------------------------| void myCustomInitializer ( uint8_t sensorAddress , TwoWire & port , void * _classPtr ) { SFE_UBLOX_GNSS * device = ( SFE_UBLOX_GNSS * ) _classPtr ; // Use _classPtr to create a pointer to the sensor class device -> setI2COutput ( COM_TYPE_UBX ); // Set the I2C port to output UBX only (turn off NMEA noise) device -> saveConfigSelective ( VAL_CFG_SUBSEC_IOPORT ); // Save (only) the communications port settings to flash and BBR device -> setAutoPVT ( true ); // Enable PVT at the navigation rate device -> setMeasurementRate ( 250 ); // Set navigation rate to 4Hz } You will see that the first three lines of the custom initializer are the same as the initializer code built in to the library. It is the 4th line setMeasurementRate(250); which sets the GNSS module to output PVT at 4Hz (intervals of 250ms) instead of 1Hz. setCustomInitialize Now that we have declared our custom initializer, we need to tell the library to use it. In the setup() code you will see: // Set up a custom initializer for a u-blox GNSS module: with I2C address 0x42, on the main branch (Mux address 0, Mux port 0) // Do this after .beginSensors but before .initializeSensors mySensors . setCustomInitialize ( & myCustomInitializer , \"SFE_UBLOX_GNSS\" , 0x42 , 0 , 0 ); // Alternatively, we can use the same custom initializer for all instances of the sensor // Again, do this after .beginSensors but before .initializeSensors mySensors . setCustomInitialize ( & myCustomInitializer , \"SFE_UBLOX_GNSS\" ); mySensors . initializeSensors (); // Initialize all the sensors If you have multiple sensors of the same type connected, you can apply the same custom initializer to all of them. This line of code causes the library to apply myCustomInitializer to all connected SFE_UBLOX_GNSS sensors: setCustomInitialize(&myCustomInitializer, \"SFE_UBLOX_GNSS\"); But, as the code suggests, you could also create separate custom initializers and apply them to the sensors individually based on their I2C address, Mux address and Mux Port (if present): setCustomInitialize(&myCustomInitializer1, \"SFE_UBLOX_GNSS\", 0x42, 0x70, 0); // Apply myCustomInitializer1 to the GNSS on Mux 0x70 Port 0 setCustomInitialize(&myCustomInitializer2, \"SFE_UBLOX_GNSS\", 0x42, 0x70, 1); // Apply myCustomInitializer2 to the GNSS on Mux 0x70 Port 1 setCustomInitialize(&myCustomInitializer3, \"SFE_UBLOX_GNSS\", 0x42, 0x70, 2); // Apply myCustomInitializer3 to the GNSS on Mux 0x70 Port 2 Because the custom initializer code is stored in your .ino code, it will not be overwritten when the library is updated!","title":"Example 4 - Custom Initialization"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_04_Custom_Initialization/#example-4-custom-initialization-how-to-change-the-sensor-initialization","text":"Another of the fantastic things about SparkFun Qwiic Universal Auto-Detect is that it will automatically initialize the sensors for you. Based on our experience with OpenLog Artemis , we have included initialization code for the sensors that require it. The code is applied when you call initializeSensors(); in setup() . But what if you want to initialize your sensor(s) differently? What do you do then? Do you need to edit the initialization code in this library - only to have your work overwritten when the library is updated? No! We have included a Custom Initialization feature to let you let you change the initialization safely and easily! In this example, we focus on the u-blox GNSS module. The initialization code inside this library looks like this: device -> setI2COutput ( COM_TYPE_UBX ); // Set the I2C port to output UBX only (turn off NMEA noise) device -> saveConfigSelective ( VAL_CFG_SUBSEC_IOPORT ); // Save (only) the communications port settings to flash and BBR device -> setAutoPVT ( true ); // Enable PVT at the navigation rate The code is doing three things which we (nearly) always need to do when communicating with a u-blox GNSS: We disable the NMEA protocol on the I2C port, leaving only UBX enabled We save the port configuration to battery-backed memory We tell the u-blox module to output its position, velocity and time (PVT) message at the standard 1Hz navigation rate The third thing prevents the u-blox GNSS library from stalling (blocking) while it waits for the next PVT message. setAutoPVT(true); causes the PVT messages to be generated periodically, and tells the library to return immediately using the data from the most recent PVT message instead of waiting for 'fresh' data to arrive. That way, you get your position immediately (even if it is slightly out of date). But what if you are always going to run the GNSS at 4Hz instead of the standard 1Hz? How do you tell the library to use your own custom initialization code? This is how:","title":"Example 4 - Custom Initialization - How to change the sensor initialization"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_04_Custom_Initialization/#custom-initializer","text":"At the start of the example, you will see the code for the custom initializer: // Define a custom initialization function for (e.g.) the u-blox GNSS // _____ You can use any name you like for the initializer. Use the same name when you call setCustomInitialize // / _____ This _must_ be uint8_t sensorAddress, TwoWire &port, void *_classPtr // | / // | | // | |--------------------^------------------------------| void myCustomInitializer ( uint8_t sensorAddress , TwoWire & port , void * _classPtr ) { SFE_UBLOX_GNSS * device = ( SFE_UBLOX_GNSS * ) _classPtr ; // Use _classPtr to create a pointer to the sensor class device -> setI2COutput ( COM_TYPE_UBX ); // Set the I2C port to output UBX only (turn off NMEA noise) device -> saveConfigSelective ( VAL_CFG_SUBSEC_IOPORT ); // Save (only) the communications port settings to flash and BBR device -> setAutoPVT ( true ); // Enable PVT at the navigation rate device -> setMeasurementRate ( 250 ); // Set navigation rate to 4Hz } You will see that the first three lines of the custom initializer are the same as the initializer code built in to the library. It is the 4th line setMeasurementRate(250); which sets the GNSS module to output PVT at 4Hz (intervals of 250ms) instead of 1Hz.","title":"Custom Initializer"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_04_Custom_Initialization/#setcustominitialize","text":"Now that we have declared our custom initializer, we need to tell the library to use it. In the setup() code you will see: // Set up a custom initializer for a u-blox GNSS module: with I2C address 0x42, on the main branch (Mux address 0, Mux port 0) // Do this after .beginSensors but before .initializeSensors mySensors . setCustomInitialize ( & myCustomInitializer , \"SFE_UBLOX_GNSS\" , 0x42 , 0 , 0 ); // Alternatively, we can use the same custom initializer for all instances of the sensor // Again, do this after .beginSensors but before .initializeSensors mySensors . setCustomInitialize ( & myCustomInitializer , \"SFE_UBLOX_GNSS\" ); mySensors . initializeSensors (); // Initialize all the sensors If you have multiple sensors of the same type connected, you can apply the same custom initializer to all of them. This line of code causes the library to apply myCustomInitializer to all connected SFE_UBLOX_GNSS sensors: setCustomInitialize(&myCustomInitializer, \"SFE_UBLOX_GNSS\"); But, as the code suggests, you could also create separate custom initializers and apply them to the sensors individually based on their I2C address, Mux address and Mux Port (if present): setCustomInitialize(&myCustomInitializer1, \"SFE_UBLOX_GNSS\", 0x42, 0x70, 0); // Apply myCustomInitializer1 to the GNSS on Mux 0x70 Port 0 setCustomInitialize(&myCustomInitializer2, \"SFE_UBLOX_GNSS\", 0x42, 0x70, 1); // Apply myCustomInitializer2 to the GNSS on Mux 0x70 Port 1 setCustomInitialize(&myCustomInitializer3, \"SFE_UBLOX_GNSS\", 0x42, 0x70, 2); // Apply myCustomInitializer3 to the GNSS on Mux 0x70 Port 2 Because the custom initializer code is stored in your .ino code, it will not be overwritten when the library is updated!","title":"setCustomInitialize"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_05_Memory_Leak_Test/","text":"Example 5 - Memory Leak Test - How to test for a memory leak In most Arduino code, it is usual to declare an object at a global scope (after the include file declaration), not within the setup() or loop() functions. Because the object is global, both setup() and loop() can access it. But you do not have to do it this way. You can, if you want to, declare the SparkFun Qwiic Universal Auto-Detect object mySensors inside the loop() : void loop () { SFE_QUAD_Sensors mySensors ; mySensors . setWirePort ( Wire ); // Tell the class which Wire port to use mySensors . enableDebugging ( Serial ); // Uncomment this line to enable debug messages on Serial mySensors . detectSensors (); // Detect which sensors are connected mySensors . beginSensors (); // Begin all the sensors mySensors . initializeSensors (); // Initialize all the sensors mySensors . getSensorNames (); // Print the sensor names helper Serial . println ( mySensors . readings ); mySensors . getSenseNames (); // Print the sense names helper Serial . println ( mySensors . readings ); mySensors . getSensorReadings (); // Read everything from all sensors Serial . println ( mySensors . readings ); delay ( 500 ); } The mySensors object is then constructed ( instantiated ) at the start of the loop, and is destructed ( deleted ) at the end of the loop. A new, fresh instance of mySensors is used each time around the loop. This is a very good test for a memory leak! Sometimes code may not release all of the memory it is using correctly when the destructor is called. Those small pieces of unreleased memory add up, increasing each time around the loop, and eventually you run out of memory. This is called a memory leak. If you run your code on a processor with very limited memory (like an ATmega328P, as used on our original RedBoards) you will run out of memory quickly. We run Example5 on a RedBoard to make sure the library has no memory leaks. (Actually, we did find one - and we fixed it!) If you want to try this yourself, you will need to edit SFE_QUAD_Sensors.h and only include one or two individual sensors to let the code compile on the ATmega328P. It does not have anywhere near enough program memory to hold all of the sensor libraries included in this library! You will find SFE_QUAD_Sensors.h in the src folder. // To include all sensors, uncomment #define INCLUDE_SFE_QUAD_SENSOR_ALL //#define INCLUDE_SFE_QUAD_SENSOR_ALL // Include all sensors // To select which sensors to include: // comment #define INCLUDE_SFE_QUAD_SENSOR_ALL // uncomment one or more #define INCLUDE_SFE_QUAD_SENSOR_ //#define INCLUDE_SFE_QUAD_SENSOR_ADS122C04 // Include individual sensors //#define INCLUDE_SFE_QUAD_SENSOR_AHT20 #define INCLUDE_SFE_QUAD_SENSOR_BME280 //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5A //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5B //#define INCLUDE_SFE_QUAD_SENSOR_LPS25HB //#define INCLUDE_SFE_QUAD_SENSOR_MAX17048 //#define INCLUDE_SFE_QUAD_SENSOR_MCP9600 //#define INCLUDE_SFE_QUAD_SENSOR_MICROPRESSURE //#define INCLUDE_SFE_QUAD_SENSOR_MS5637 //#define INCLUDE_SFE_QUAD_SENSOR_MS8607 //#define INCLUDE_SFE_QUAD_SENSOR_NAU7802 //#define INCLUDE_SFE_QUAD_SENSOR_QWIICBUTTON //#define INCLUDE_SFE_QUAD_SENSOR_SCD30 //#define INCLUDE_SFE_QUAD_SENSOR_SCD40 //#define INCLUDE_SFE_QUAD_SENSOR_SDP3X //#define INCLUDE_SFE_QUAD_SENSOR_SGP30 //#define INCLUDE_SFE_QUAD_SENSOR_SGP40 //#define INCLUDE_SFE_QUAD_SENSOR_SHTC3 //#define INCLUDE_SFE_QUAD_SENSOR_STC31 //#define INCLUDE_SFE_QUAD_SENSOR_TMP117 //#define INCLUDE_SFE_QUAD_SENSOR_UBLOX_GNSS //#define INCLUDE_SFE_QUAD_SENSOR_VCNL4040 //#define INCLUDE_SFE_QUAD_SENSOR_VEML6075 //#define INCLUDE_SFE_QUAD_SENSOR_VEML7700 //#define INCLUDE_SFE_QUAD_SENSOR_VL53L1X","title":"Example 5 - Memory Leak Test"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_05_Memory_Leak_Test/#example-5-memory-leak-test-how-to-test-for-a-memory-leak","text":"In most Arduino code, it is usual to declare an object at a global scope (after the include file declaration), not within the setup() or loop() functions. Because the object is global, both setup() and loop() can access it. But you do not have to do it this way. You can, if you want to, declare the SparkFun Qwiic Universal Auto-Detect object mySensors inside the loop() : void loop () { SFE_QUAD_Sensors mySensors ; mySensors . setWirePort ( Wire ); // Tell the class which Wire port to use mySensors . enableDebugging ( Serial ); // Uncomment this line to enable debug messages on Serial mySensors . detectSensors (); // Detect which sensors are connected mySensors . beginSensors (); // Begin all the sensors mySensors . initializeSensors (); // Initialize all the sensors mySensors . getSensorNames (); // Print the sensor names helper Serial . println ( mySensors . readings ); mySensors . getSenseNames (); // Print the sense names helper Serial . println ( mySensors . readings ); mySensors . getSensorReadings (); // Read everything from all sensors Serial . println ( mySensors . readings ); delay ( 500 ); } The mySensors object is then constructed ( instantiated ) at the start of the loop, and is destructed ( deleted ) at the end of the loop. A new, fresh instance of mySensors is used each time around the loop. This is a very good test for a memory leak! Sometimes code may not release all of the memory it is using correctly when the destructor is called. Those small pieces of unreleased memory add up, increasing each time around the loop, and eventually you run out of memory. This is called a memory leak. If you run your code on a processor with very limited memory (like an ATmega328P, as used on our original RedBoards) you will run out of memory quickly. We run Example5 on a RedBoard to make sure the library has no memory leaks. (Actually, we did find one - and we fixed it!) If you want to try this yourself, you will need to edit SFE_QUAD_Sensors.h and only include one or two individual sensors to let the code compile on the ATmega328P. It does not have anywhere near enough program memory to hold all of the sensor libraries included in this library! You will find SFE_QUAD_Sensors.h in the src folder. // To include all sensors, uncomment #define INCLUDE_SFE_QUAD_SENSOR_ALL //#define INCLUDE_SFE_QUAD_SENSOR_ALL // Include all sensors // To select which sensors to include: // comment #define INCLUDE_SFE_QUAD_SENSOR_ALL // uncomment one or more #define INCLUDE_SFE_QUAD_SENSOR_ //#define INCLUDE_SFE_QUAD_SENSOR_ADS122C04 // Include individual sensors //#define INCLUDE_SFE_QUAD_SENSOR_AHT20 #define INCLUDE_SFE_QUAD_SENSOR_BME280 //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5A //#define INCLUDE_SFE_QUAD_SENSOR_CCS811_5B //#define INCLUDE_SFE_QUAD_SENSOR_LPS25HB //#define INCLUDE_SFE_QUAD_SENSOR_MAX17048 //#define INCLUDE_SFE_QUAD_SENSOR_MCP9600 //#define INCLUDE_SFE_QUAD_SENSOR_MICROPRESSURE //#define INCLUDE_SFE_QUAD_SENSOR_MS5637 //#define INCLUDE_SFE_QUAD_SENSOR_MS8607 //#define INCLUDE_SFE_QUAD_SENSOR_NAU7802 //#define INCLUDE_SFE_QUAD_SENSOR_QWIICBUTTON //#define INCLUDE_SFE_QUAD_SENSOR_SCD30 //#define INCLUDE_SFE_QUAD_SENSOR_SCD40 //#define INCLUDE_SFE_QUAD_SENSOR_SDP3X //#define INCLUDE_SFE_QUAD_SENSOR_SGP30 //#define INCLUDE_SFE_QUAD_SENSOR_SGP40 //#define INCLUDE_SFE_QUAD_SENSOR_SHTC3 //#define INCLUDE_SFE_QUAD_SENSOR_STC31 //#define INCLUDE_SFE_QUAD_SENSOR_TMP117 //#define INCLUDE_SFE_QUAD_SENSOR_UBLOX_GNSS //#define INCLUDE_SFE_QUAD_SENSOR_VCNL4040 //#define INCLUDE_SFE_QUAD_SENSOR_VEML6075 //#define INCLUDE_SFE_QUAD_SENSOR_VEML7700 //#define INCLUDE_SFE_QUAD_SENSOR_VL53L1X","title":"Example 5 - Memory Leak Test - How to test for a memory leak"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/","text":"Example 6 - ESP32 Thing Plus C Logger - Logging sensor data to microSD card A more complex example to show how to log sensor data to microSD card using the SparkFun Qwiic Universal Auto-Detect and SdFat libraries. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms. Key Features Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Log data to microSD card using the SdFat library The logging rate / interval is set by the menu Writing the settings to microSD card using SdFat Reading the settings back from microSD card and applying them This example is very similar to Example1 . Please see the Example1 documentation for a full walk-through of the code. Let's walk through the key differences: Setup For this example, we need to: include the header files for SdFat and this library; and create a SFE_QUAD_Sensors__SdFat object. #include <SdFat.h> // Include SdFat.h to enable support for SFE_QUAD_Sensors__SdFat. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect SFE_QUAD_Sensors__SdFat mySensors ; We are using Bill Greiman's SdFat library as it: is very fast; and supports FAT16, FAT32 and exFAT. You can install SdFat through the Arduino IDE Library Manager: search for SdFat exFAT . The Menu One of the key differences in this example is that it uses the built-in menu to control the logging rate. You will notice that the menu definition contains extra lines: mySensors . theMenu . addMenuItem ( \"Logging interval (ms)\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); SFE_QUAD_Menu_Every_Type_t defaultValue ; defaultValue . ULONG = 1000 ; mySensors . theMenu . setMenuItemVariable ( \"Logging interval (ms)\" , & defaultValue ); // Set the default logging interval - this will be updated by readConfig defaultValue . ULONG = 100 ; mySensors . theMenu . setMenuItemVariableMin ( \"Logging interval (ms)\" , & defaultValue ); // Set the minimum logging interval - this will be updated by readConfig defaultValue . ULONG = 3600000 ; mySensors . theMenu . setMenuItemVariableMax ( \"Logging interval (ms)\" , & defaultValue ); // Set the maximum logging interval - this will be updated by readConfig As before, most of the menu items are SFE_QUAD_MENU_VARIABLE_TYPE_NONE (for the lines of plain text) or SFE_QUAD_MENU_VARIABLE_TYPE_CODE (a function which is called by the menu). In this example we have added an SFE_QUAD_MENU_VARIABLE_TYPE_ULONG item and have given it the name Logging interval (ms) . All Arduino platforms provide a millisecond counter called millis() . It returns a count of milliseconds as an unsigned long (usually 32-bit) number. We use that to control the logging rate by comparing it to the Logging interval (ms) . This line creates the logging interval menu item: mySensors.theMenu.addMenuItem(\"Logging interval (ms)\", SFE_QUAD_MENU_VARIABLE_TYPE_ULONG); These three lines give Logging interval (ms) a default / initial value of 1000 (milliseconds): SFE_QUAD_Menu_Every_Type_t defaultValue; defaultValue.ULONG = 1000; mySensors.theMenu.setMenuItemVariable(\"Logging interval (ms)\", &defaultValue); The first of those lines creates a variable called defaultValue of type SFE_QUAD_Menu_Every_Type_t . SFE_QUAD_Menu_Every_Type_t is a struct containing, as the name suggests, one of every type. Here is its definition in the library: // Struct to hold \"every type\" typedef struct { void ( * CODE )(); char * TEXT ; bool BOOL ; float FLOAT ; double DOUBLE ; int INT ; uint8_t UINT8_T ; uint16_t UINT16_T ; uint32_t UINT32_T ; unsigned long ULONG ; long LONG ; } SFE_QUAD_Menu_Every_Type_t ; The second line of code loads the ULONG (unsigned long) with 1000. The third copies defaultValue into the linked-list menu entry for Logging interval (ms) . This provides the default or initial value for Logging interval (ms) , but the code will automatically update it with the value stored on microSD card when we call readConfig(); The next four lines re-use defaultValue to set minimum and maximum values / limits for Logging interval (ms) . The minimum and maximum values are optional, but, if you do not include them, the code will accept any value from zero to the maximum an unsigned long can hold. The code sets sensible limits of 100ms and 3600000ms (one hour): defaultValue.ULONG = 100; mySensors.theMenu.setMenuItemVariableMin(\"Logging interval (ms)\", &defaultValue); defaultValue.ULONG = 3600000; mySensors.theMenu.setMenuItemVariableMax(\"Logging interval (ms)\", &defaultValue); In the main loop() , we can read whatever value Logging interval (ms) has been set to, and use it to control when the sensors are read by comparing it to millis() : // Logging interval - read the sensors every loggingInterval milliseconds static unsigned long lastRead = 0 ; SFE_QUAD_Menu_Every_Type_t loggingInterval ; mySensors . theMenu . getMenuItemVariable ( \"Logging interval (ms)\" , & loggingInterval ); // Get the logging interval from theMenu if ( millis () > ( lastRead + loggingInterval . ULONG )) // Is it time to read the sensors? { lastRead = millis (); // Update the time of the last read lastRead is a static variable which holds a copy of millis() . Because it is static , it retains its value each time the code goes around the loop() . (It is only set to zero the first time around the loop.) (We could have declared it as a global variable, before setup() , instead.) loggingInterval is another SFE_QUAD_Menu_Every_Type_t . We read the value of Logging interval (ms) from the menu linked-list and copy it into loggingInterval with this line of code: mySensors.theMenu.getMenuItemVariable(\"Logging interval (ms)\", &loggingInterval); We then compare loggingInterval to the copy of millis() , held in lastRead , to decide when to take the next reading. If we change loggingInterval by opening the menu and selecting option 1, the code will automatically use the new interval from then on! Here is the value being changed from the default 1000ms to 500ms. Note the minimum and maximum values we set earlier. The menu will reject any values outside of those. Menu ==== 1 : Logging interval (ms) : 1000 2 : Stop logging 3 : Open the sensor logging menu 4 : Open the sensor settings menu 5 : Write the logger configuration to SD 6 : Read the logger configuration from SD Enter a number, or enter 0 to exit: 1 Enter the value (unsigned long) (Min: 100) (Max: 3600000) : 500 Menu ==== 1 : Logging interval (ms) : 500 2 : Stop logging 3 : Open the sensor logging menu 4 : Open the sensor settings menu 5 : Write the logger configuration to SD 6 : Read the logger configuration from SD Enter a number, or enter 0 to exit: We can save the new value to SD card by selecting option 5. Logging data to SD card The previous examples have not actually logged (saved or recorded) any sensor readings. They have only printed them to Serial. But we do of course want to save (write) that data to SD card so we can study it later. Here is the extra code which lets us do that. Creating a File object SdFat allows us to use several different file types. SparkFun Qwiic Universal Auto-Detect defaults to using an FsFile object as it supports FAT16, FAT32 and exFAT (for very large files). SFE_QUAD_SD_FAT_TYPE is set to 3 inside SFE_QUAD_Sensors.h . The example contains the following code just in case SFE_QUAD_SD_FAT_TYPE has been changed: // Define the log file type - use the same type as the Qwiic Universal Auto-Detect library #if SFE_QUAD_SD_FAT_TYPE == 1 File32 sensorDataFile ; //File that all sensor data is written to #elif SFE_QUAD_SD_FAT_TYPE == 2 ExFile sensorDataFile ; //File that all sensor data is written to #elif SFE_QUAD_SD_FAT_TYPE == 3 FsFile sensorDataFile ; //File that all sensor data is written to #else // SD_FAT_TYPE == 0 File sensorDataFile ; //File that all sensor data is written to #endif // SD_FAT_TYPE char sensorDataFileName [ 30 ] = \"\" ; // This will hold the name of the sensorDataFile bool onlineDataLogging ; //This flag indicates if we are logging data to sensorDataFile This creates a FsFile object called sensorDataFile . We have not yet opened the file, or given it a name. We do that within setup() : // mySensors.beginStorage has done the sd.begin for us // Open the next available log file onlineDataLogging = false ; Serial . println ( F ( \"Finding the next available log file...\" )); if ( findNextAvailableLog ( sensorDataFileName , \"dataLog\" , false )) // Do not reuse empty files - to save time { // O_CREAT - create the file if it does not exist // O_APPEND - seek to the end of the file prior to each write // O_WRITE - open for write onlineDataLogging = sensorDataFile . open ( sensorDataFileName , O_CREAT | O_APPEND | O_WRITE ) == true ; } Normally we would need to call sd.begin but mySensors.beginStorage has done that for us. The example re-uses the SdFs sd object which is created in SFE_QUAD_Sensors.h . onlineDataLogging is the global bool we created above. We use it as a flag to indicate that the log file is open and that data can be written to it. findNextAvailableLog is a helper function which finds the name of the next available file, by adding a five digit sequential number to \"dataLog\". The data log files are called: dataLog00000.csv dataLog00001.csv dataLog00002.csv etc.. You will find the code for findNextAvailableLog at the bottom of the example. Writing data to file The sensor and sense helper text is written into the log file by these lines: mySensors . getSensorNames (); // Print the sensor names helper if ( onlineDataLogging ) sensorDataFile . println ( mySensors . readings ); mySensors . getSenseNames (); // Print the sense names helper if ( onlineDataLogging ) sensorDataFile . println ( mySensors . readings ); A new log file is created each time you open the logging menu as the sensor and sense helper text may have changed. The sense data is written to file by these lines. They also flash LED_BUILTIN to indicate that the write is taking place: if ( onlineDataLogging ) { digitalWrite ( LED_BUILTIN , HIGH ); sensorDataFile . println ( mySensors . readings ); // Write the data to file sensorDataFile . sync (); // This will help prevent data loss if the power is removed during logging digitalWrite ( LED_BUILTIN , LOW ); } Closing the log file The sensorDataFile.sync(); should prevent data loss if you disconnect the power while the log file is still open. But, for safety, you should always close the log file before removing the power. Call stopLogging() via the menu or by pressing the stop-logging button. stopLogging() closes the log file: void stopLogging ( void ) { if ( onlineDataLogging ) { sensorDataFile . close (); onlineDataLogging = false ; Serial . println ( F ( \"Log file closed\" )); } } Stop-Logging Button Most ESP32 boards have a BOOT button which can be used as a general-purpose input when code is running. This example uses the BOOT button as a stop-logging button. On the Thing Plus C , the BOOT pin (digital pin 0) is normally used as an output to enable the voltage regulator for the Qwiic bus: int qwiicPower = 0 ; //Thing Plus C digital pin 0 is connected to the v-reg that controls the Qwiic power. It is also connected to the BOOT button. However, we can 'cheat' and use it as an input if we set it to INPUT_PULLUP in setup() . The pull-up resistor, when enabled, is enough to enable the Qwiic voltage regulator: // Enable power for the Qwiic bus // The input pull-up is enough to enable the regulator // We can then also use the BOOT button as a \"stop logging\" button pinMode ( qwiicPower , INPUT_PULLUP ); The loop() checks if the button has been pressed and closes the log file if it has: if ( digitalRead ( qwiicPower ) == LOW ) // Check if the user has pressed the stop logging button { stopLogging (); } On the Thing Plus C, pressing the BOOT button will disable the power for the Qwiic bus and power-off all of the sensors. When you release the button, the Qwiic power will be re-enabled but the sensors will need to be re-initialized before you can use them. You will need to press the RST (RESET) button, or power the board off and on again, to re-start the code and re-initialize the sensors.","title":"Example 6 - Thing Plus C Logger"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#example-6-esp32-thing-plus-c-logger-logging-sensor-data-to-microsd-card","text":"A more complex example to show how to log sensor data to microSD card using the SparkFun Qwiic Universal Auto-Detect and SdFat libraries. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for many platforms.","title":"Example 6 - ESP32 Thing Plus C Logger - Logging sensor data to microSD card"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#key-features","text":"Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the sensor settings through the menu system Log data to microSD card using the SdFat library The logging rate / interval is set by the menu Writing the settings to microSD card using SdFat Reading the settings back from microSD card and applying them This example is very similar to Example1 . Please see the Example1 documentation for a full walk-through of the code. Let's walk through the key differences:","title":"Key Features"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#setup","text":"For this example, we need to: include the header files for SdFat and this library; and create a SFE_QUAD_Sensors__SdFat object. #include <SdFat.h> // Include SdFat.h to enable support for SFE_QUAD_Sensors__SdFat. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect SFE_QUAD_Sensors__SdFat mySensors ; We are using Bill Greiman's SdFat library as it: is very fast; and supports FAT16, FAT32 and exFAT. You can install SdFat through the Arduino IDE Library Manager: search for SdFat exFAT .","title":"Setup"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#the-menu","text":"One of the key differences in this example is that it uses the built-in menu to control the logging rate. You will notice that the menu definition contains extra lines: mySensors . theMenu . addMenuItem ( \"Logging interval (ms)\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); SFE_QUAD_Menu_Every_Type_t defaultValue ; defaultValue . ULONG = 1000 ; mySensors . theMenu . setMenuItemVariable ( \"Logging interval (ms)\" , & defaultValue ); // Set the default logging interval - this will be updated by readConfig defaultValue . ULONG = 100 ; mySensors . theMenu . setMenuItemVariableMin ( \"Logging interval (ms)\" , & defaultValue ); // Set the minimum logging interval - this will be updated by readConfig defaultValue . ULONG = 3600000 ; mySensors . theMenu . setMenuItemVariableMax ( \"Logging interval (ms)\" , & defaultValue ); // Set the maximum logging interval - this will be updated by readConfig As before, most of the menu items are SFE_QUAD_MENU_VARIABLE_TYPE_NONE (for the lines of plain text) or SFE_QUAD_MENU_VARIABLE_TYPE_CODE (a function which is called by the menu). In this example we have added an SFE_QUAD_MENU_VARIABLE_TYPE_ULONG item and have given it the name Logging interval (ms) . All Arduino platforms provide a millisecond counter called millis() . It returns a count of milliseconds as an unsigned long (usually 32-bit) number. We use that to control the logging rate by comparing it to the Logging interval (ms) . This line creates the logging interval menu item: mySensors.theMenu.addMenuItem(\"Logging interval (ms)\", SFE_QUAD_MENU_VARIABLE_TYPE_ULONG); These three lines give Logging interval (ms) a default / initial value of 1000 (milliseconds): SFE_QUAD_Menu_Every_Type_t defaultValue; defaultValue.ULONG = 1000; mySensors.theMenu.setMenuItemVariable(\"Logging interval (ms)\", &defaultValue); The first of those lines creates a variable called defaultValue of type SFE_QUAD_Menu_Every_Type_t . SFE_QUAD_Menu_Every_Type_t is a struct containing, as the name suggests, one of every type. Here is its definition in the library: // Struct to hold \"every type\" typedef struct { void ( * CODE )(); char * TEXT ; bool BOOL ; float FLOAT ; double DOUBLE ; int INT ; uint8_t UINT8_T ; uint16_t UINT16_T ; uint32_t UINT32_T ; unsigned long ULONG ; long LONG ; } SFE_QUAD_Menu_Every_Type_t ; The second line of code loads the ULONG (unsigned long) with 1000. The third copies defaultValue into the linked-list menu entry for Logging interval (ms) . This provides the default or initial value for Logging interval (ms) , but the code will automatically update it with the value stored on microSD card when we call readConfig(); The next four lines re-use defaultValue to set minimum and maximum values / limits for Logging interval (ms) . The minimum and maximum values are optional, but, if you do not include them, the code will accept any value from zero to the maximum an unsigned long can hold. The code sets sensible limits of 100ms and 3600000ms (one hour): defaultValue.ULONG = 100; mySensors.theMenu.setMenuItemVariableMin(\"Logging interval (ms)\", &defaultValue); defaultValue.ULONG = 3600000; mySensors.theMenu.setMenuItemVariableMax(\"Logging interval (ms)\", &defaultValue); In the main loop() , we can read whatever value Logging interval (ms) has been set to, and use it to control when the sensors are read by comparing it to millis() : // Logging interval - read the sensors every loggingInterval milliseconds static unsigned long lastRead = 0 ; SFE_QUAD_Menu_Every_Type_t loggingInterval ; mySensors . theMenu . getMenuItemVariable ( \"Logging interval (ms)\" , & loggingInterval ); // Get the logging interval from theMenu if ( millis () > ( lastRead + loggingInterval . ULONG )) // Is it time to read the sensors? { lastRead = millis (); // Update the time of the last read lastRead is a static variable which holds a copy of millis() . Because it is static , it retains its value each time the code goes around the loop() . (It is only set to zero the first time around the loop.) (We could have declared it as a global variable, before setup() , instead.) loggingInterval is another SFE_QUAD_Menu_Every_Type_t . We read the value of Logging interval (ms) from the menu linked-list and copy it into loggingInterval with this line of code: mySensors.theMenu.getMenuItemVariable(\"Logging interval (ms)\", &loggingInterval); We then compare loggingInterval to the copy of millis() , held in lastRead , to decide when to take the next reading. If we change loggingInterval by opening the menu and selecting option 1, the code will automatically use the new interval from then on! Here is the value being changed from the default 1000ms to 500ms. Note the minimum and maximum values we set earlier. The menu will reject any values outside of those. Menu ==== 1 : Logging interval (ms) : 1000 2 : Stop logging 3 : Open the sensor logging menu 4 : Open the sensor settings menu 5 : Write the logger configuration to SD 6 : Read the logger configuration from SD Enter a number, or enter 0 to exit: 1 Enter the value (unsigned long) (Min: 100) (Max: 3600000) : 500 Menu ==== 1 : Logging interval (ms) : 500 2 : Stop logging 3 : Open the sensor logging menu 4 : Open the sensor settings menu 5 : Write the logger configuration to SD 6 : Read the logger configuration from SD Enter a number, or enter 0 to exit: We can save the new value to SD card by selecting option 5.","title":"The Menu"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#logging-data-to-sd-card","text":"The previous examples have not actually logged (saved or recorded) any sensor readings. They have only printed them to Serial. But we do of course want to save (write) that data to SD card so we can study it later. Here is the extra code which lets us do that.","title":"Logging data to SD card"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#creating-a-file-object","text":"SdFat allows us to use several different file types. SparkFun Qwiic Universal Auto-Detect defaults to using an FsFile object as it supports FAT16, FAT32 and exFAT (for very large files). SFE_QUAD_SD_FAT_TYPE is set to 3 inside SFE_QUAD_Sensors.h . The example contains the following code just in case SFE_QUAD_SD_FAT_TYPE has been changed: // Define the log file type - use the same type as the Qwiic Universal Auto-Detect library #if SFE_QUAD_SD_FAT_TYPE == 1 File32 sensorDataFile ; //File that all sensor data is written to #elif SFE_QUAD_SD_FAT_TYPE == 2 ExFile sensorDataFile ; //File that all sensor data is written to #elif SFE_QUAD_SD_FAT_TYPE == 3 FsFile sensorDataFile ; //File that all sensor data is written to #else // SD_FAT_TYPE == 0 File sensorDataFile ; //File that all sensor data is written to #endif // SD_FAT_TYPE char sensorDataFileName [ 30 ] = \"\" ; // This will hold the name of the sensorDataFile bool onlineDataLogging ; //This flag indicates if we are logging data to sensorDataFile This creates a FsFile object called sensorDataFile . We have not yet opened the file, or given it a name. We do that within setup() : // mySensors.beginStorage has done the sd.begin for us // Open the next available log file onlineDataLogging = false ; Serial . println ( F ( \"Finding the next available log file...\" )); if ( findNextAvailableLog ( sensorDataFileName , \"dataLog\" , false )) // Do not reuse empty files - to save time { // O_CREAT - create the file if it does not exist // O_APPEND - seek to the end of the file prior to each write // O_WRITE - open for write onlineDataLogging = sensorDataFile . open ( sensorDataFileName , O_CREAT | O_APPEND | O_WRITE ) == true ; } Normally we would need to call sd.begin but mySensors.beginStorage has done that for us. The example re-uses the SdFs sd object which is created in SFE_QUAD_Sensors.h . onlineDataLogging is the global bool we created above. We use it as a flag to indicate that the log file is open and that data can be written to it. findNextAvailableLog is a helper function which finds the name of the next available file, by adding a five digit sequential number to \"dataLog\". The data log files are called: dataLog00000.csv dataLog00001.csv dataLog00002.csv etc.. You will find the code for findNextAvailableLog at the bottom of the example.","title":"Creating a File object"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#writing-data-to-file","text":"The sensor and sense helper text is written into the log file by these lines: mySensors . getSensorNames (); // Print the sensor names helper if ( onlineDataLogging ) sensorDataFile . println ( mySensors . readings ); mySensors . getSenseNames (); // Print the sense names helper if ( onlineDataLogging ) sensorDataFile . println ( mySensors . readings ); A new log file is created each time you open the logging menu as the sensor and sense helper text may have changed. The sense data is written to file by these lines. They also flash LED_BUILTIN to indicate that the write is taking place: if ( onlineDataLogging ) { digitalWrite ( LED_BUILTIN , HIGH ); sensorDataFile . println ( mySensors . readings ); // Write the data to file sensorDataFile . sync (); // This will help prevent data loss if the power is removed during logging digitalWrite ( LED_BUILTIN , LOW ); }","title":"Writing data to file"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#closing-the-log-file","text":"The sensorDataFile.sync(); should prevent data loss if you disconnect the power while the log file is still open. But, for safety, you should always close the log file before removing the power. Call stopLogging() via the menu or by pressing the stop-logging button. stopLogging() closes the log file: void stopLogging ( void ) { if ( onlineDataLogging ) { sensorDataFile . close (); onlineDataLogging = false ; Serial . println ( F ( \"Log file closed\" )); } }","title":"Closing the log file"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_06_Thing_Plus_C_Logger/#stop-logging-button","text":"Most ESP32 boards have a BOOT button which can be used as a general-purpose input when code is running. This example uses the BOOT button as a stop-logging button. On the Thing Plus C , the BOOT pin (digital pin 0) is normally used as an output to enable the voltage regulator for the Qwiic bus: int qwiicPower = 0 ; //Thing Plus C digital pin 0 is connected to the v-reg that controls the Qwiic power. It is also connected to the BOOT button. However, we can 'cheat' and use it as an input if we set it to INPUT_PULLUP in setup() . The pull-up resistor, when enabled, is enough to enable the Qwiic voltage regulator: // Enable power for the Qwiic bus // The input pull-up is enough to enable the regulator // We can then also use the BOOT button as a \"stop logging\" button pinMode ( qwiicPower , INPUT_PULLUP ); The loop() checks if the button has been pressed and closes the log file if it has: if ( digitalRead ( qwiicPower ) == LOW ) // Check if the user has pressed the stop logging button { stopLogging (); } On the Thing Plus C, pressing the BOOT button will disable the power for the Qwiic bus and power-off all of the sensors. When you release the button, the Qwiic power will be re-enabled but the sensors will need to be re-initialized before you can use them. You will need to press the RST (RESET) button, or power the board off and on again, to re-start the code and re-initialize the sensors.","title":"Stop-Logging Button"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/","text":"Example 7 - ESP32 Thing Plus C Logger RTC - Logging sensor data with Real Time Clock support A more complex example to show how to log sensor data to microSD card using SparkFun Qwiic Universal Auto-Detect. This example includes Real Time Clock (RTC) support. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for other ESP32 platforms. Key Features Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the WiFi SSID and password through the menu system Setting a Time Zone Rule through the menu Connecting to WiFi and setting the ESP32 RTC using NTP Configuring the sensor settings through the menu Log data to microSD card using the SdFat library The logging rate / interval is set by the menu Writing the settings to microSD card using SdFat Reading the settings back from microSD card and applying them This example is very similar to Example6 . Please see the Example1 and Example6 documentation for a full walk-through of the code. Let's walk through the key differences: ESP32 WiFi and RTC The code needs to include extra libraries to support ESP32 WiFi, RTC time and SNTP (Secure Network Time Protocol): #include <WiFi.h> #include \"time.h\" #include \"sntp.h\" The Menu The main difference in this example is that it uses the built-in menu to: Set the WiFi SSID and password Set the names of the NTP (Network Time Protocol) servers Set the RTC Time Zone Rule Set whether to log local time You will notice that the menu definition contains a complete sub-menu for the WiFi and NTP settings (note the SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START ): // WiFi sub-menu: set the WiFi SSID and password mySensors . theMenu . addMenuItem ( \"WiFi Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START ); // Start of the WiFi sub-menu mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"WiFi Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"=========\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"WiFi SSID\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"WiFi SSID\" , \"T-Rex\" ); // Set the default SSID - this will be updated by readLoggerConfig mySensors . theMenu . addMenuItem ( \"WiFi password\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"WiFi password\" , \"Has Big Teeth\" ); // Set the default password - this will be updated by readLoggerConfig mySensors . theMenu . addMenuItem ( \"NTP Server 1\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"NTP Server 1\" , \"pool.ntp.org\" ); mySensors . theMenu . addMenuItem ( \"NTP Server 2\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"NTP Server 2\" , \"time.nist.gov\" ); mySensors . theMenu . addMenuItem ( \"TimeZone Rule\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"TimeZone Rule\" , \"MST7MDT,M3.2.0,M11.1.0\" ); // TimeZone rule for America/Denver mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"A list of rules for your time zone can be obtained from:\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_END ); // End of the WiFi sub-menu The sub-menu contains several SFE_QUAD_MENU_VARIABLE_TYPE_TEXT items to hold: The WiFi SSID (the name of the WiFi network you want to connect to) The WiFi password The names of the NTP servers The Time Zone Rule (which will automatically set the RTC to local time and adjust for daylight saving) The setMenuItemVariable lines define the default / initial values for the text items. But, again, these can be updated via the menu or by reading the configuration from SD card. The WiFi sub-menu is opened by selecting option 8 from the main menu: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Open new log file 4 : Stop logging 5 : Set RTC using NTP over WiFi 6 : Write the logger configuration to file 7 : Read the logger configuration from file 8 : WiFi Menu 9 : Logging Menu Enter a number, or enter 0 to exit: 8 WiFi Menu ========= 1 : WiFi SSID : T-Rex 2 : WiFi password : Has Big Teeth 3 : NTP Server 1 : pool.ntp.org 4 : NTP Server 2 : time.nist.gov 5 : TimeZone Rule : MST7MDT,M3.2.0,M11.1.0 A list of rules for your time zone can be obtained from: https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h Enter a number, or enter 0 to exit: To change (e.g.) the name of NTP Server 1, select option 3 and then enter the new name: WiFi Menu ========= 1 : WiFi SSID : T-Rex 2 : WiFi password : Has Big Teeth 3 : NTP Server 1 : pool.ntp.org 4 : NTP Server 2 : time.nist.gov 5 : TimeZone Rule : MST7MDT,M3.2.0,M11.1.0 A list of rules for your time zone can be obtained from: https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h Enter a number, or enter 0 to exit: 3 Enter the value (text): europe.pool.ntp.org WiFi Menu ========= 1 : WiFi SSID : T-Rex 2 : WiFi password : Has Big Teeth 3 : NTP Server 1 : europe.pool.ntp.org 4 : NTP Server 2 : time.nist.gov 5 : TimeZone Rule : MST7MDT,M3.2.0,M11.1.0 A list of rules for your time zone can be obtained from: https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h Enter a number, or enter 0 to exit: As before, the updated settings can be saved to SD card with main menu option 6. If you are using a terminal emulator, like Tera Term, you may want to enable backspace support. This allows you to edit existing TEXT values without having to re-enter the whole text each time. // The Arduino IDE Serial Monitor does not support backspace so - by default - we need to clear text values when editing them. // The user enters the entire text value each time. // If the user is using a terminal emulator which supports backspace (e.g. Tera Term) then // setting supportsBackspace to true will allow the existing text to be edited. mySensors . theMenu . setMenuPort ( serialQUAD , true ); // Uncomment this line to use serialQUAD for the menu - on a terminal emulator which supports backspace Setting the RTC Setting the RTC is a two-step process: The ESP32 connects to WiFi The ESP32 requests network time from the NTP server(s) and sets the RTC accordingly (using the Time Zone Rule) The code in setRTC() is taken mostly from Espressif's SimpleTime example. The WiFi SSID and password are copied from the menu linked-list into char arrays ssid and password . The WiFi.begin then uses the copies: char ssid [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi SSID\" , ssid , 32 ); char password [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi password\" , password , 32 ); serialQUAD . printf ( \"Connecting to %s \" , ssid ); WiFi . begin ( ssid , password ); const unsigned long wifiConnectTimeout = 10000 ; // Allow 10s for WiFi connection unsigned long startTime = millis (); while (( WiFi . status () != WL_CONNECTED ) && ( millis () < ( startTime + wifiConnectTimeout ))) { delay ( 500 ); serialQUAD . print ( \".\" ); } The names of the NTP servers and the Time Zone Rule are copied and passed into configTzTime : char time_zone [ 50 ]; mySensors . theMenu . getMenuItemVariable ( \"TimeZone Rule\" , time_zone , 50 ); char ntpServer1 [ 20 ]; mySensors . theMenu . getMenuItemVariable ( \"NTP Server 1\" , ntpServer1 , 20 ); char ntpServer2 [ 20 ]; mySensors . theMenu . getMenuItemVariable ( \"NTP Server 2\" , ntpServer2 , 20 ); configTzTime ( time_zone , ntpServer1 , ntpServer2 ); There is no function call to specifically set the RTC, it is handled automatically when getLocalTime is requested: if ( WiFi . status () == WL_CONNECTED ) { serialQUAD . println ( \" CONNECTED\" ); struct tm timeinfo ; // Doing a getLocalTime immediately after the WiFi connects seems critical to NTP being successful?! getLocalTime ( & timeinfo ); } In this example, the WiFi connection is only used to set the RTC, so the WiFi connection is closed once getLocalTime returns. Log Local Time By default, the RTC local time will be included in the log file. But you can disable it if you want to. The Logging Sub-Menu includes a bool (boolean) item called Log Local Time : mySensors . theMenu . addMenuItem ( \"Log Local Time\" , SFE_QUAD_MENU_VARIABLE_TYPE_BOOL ); defaultValue . BOOL = 1 ; mySensors . theMenu . setMenuItemVariable ( \"Log Local Time\" , & defaultValue ); In the loop() , Log Local Time controls if the local time is printed and added to the log file (before mySensors.readings ): SFE_QUAD_Menu_Every_Type_t logLocalTime ; mySensors . theMenu . getMenuItemVariable ( \"Log Local Time\" , & logLocalTime ); if ( logLocalTime . BOOL ) printLocalTime ( serialQUAD ); // Print local time if desired serialQUAD . println ( mySensors . readings ); // Print the sensor readings if ( onlineDataLogging ) { digitalWrite ( LED_BUILTIN , HIGH ); if ( logLocalTime . BOOL ) printLocalTime ( sensorDataFile ); // Write local time to the file if desired sensorDataFile . println ( mySensors . readings ); // Write the data to file The helper function printLocalTime prints the RTC time to Serial or the log file in YYYY/MM/DD HH:MM:SS format: void printLocalTime ( Print & pr ) { // getLocalTime stalls for several seconds if the RTC has not been set (using NTP) // Use gettimeofday instead (and manually convert to tm) struct timeval tv ; struct timezone tz ; gettimeofday ( & tv , & tz ); time_t t = ( time_t ) tv . tv_sec ; struct tm * timeinfo ; timeinfo = localtime ( & t ); pr . print ( timeinfo , \"%Y/%m/%d %H:%M:%S,\" ); } Log File Timestamps This example includes two new support functions: updateDataFileCreate and updateDataFileAccess . These make use of SdFat's timestamp method to set the log file creation and write times to local (RTC) time. When you look at the directory of the microSD card on your computer, you will notice that the file times and dates are correct.","title":"Example 7 - Thing Plus C Logger RTC"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#example-7-esp32-thing-plus-c-logger-rtc-logging-sensor-data-with-real-time-clock-support","text":"A more complex example to show how to log sensor data to microSD card using SparkFun Qwiic Universal Auto-Detect. This example includes Real Time Clock (RTC) support. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for other ESP32 platforms.","title":"Example 7 - ESP32 Thing Plus C Logger RTC - Logging sensor data with Real Time Clock support"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#key-features","text":"Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the WiFi SSID and password through the menu system Setting a Time Zone Rule through the menu Connecting to WiFi and setting the ESP32 RTC using NTP Configuring the sensor settings through the menu Log data to microSD card using the SdFat library The logging rate / interval is set by the menu Writing the settings to microSD card using SdFat Reading the settings back from microSD card and applying them This example is very similar to Example6 . Please see the Example1 and Example6 documentation for a full walk-through of the code. Let's walk through the key differences:","title":"Key Features"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#esp32-wifi-and-rtc","text":"The code needs to include extra libraries to support ESP32 WiFi, RTC time and SNTP (Secure Network Time Protocol): #include <WiFi.h> #include \"time.h\" #include \"sntp.h\"","title":"ESP32 WiFi and RTC"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#the-menu","text":"The main difference in this example is that it uses the built-in menu to: Set the WiFi SSID and password Set the names of the NTP (Network Time Protocol) servers Set the RTC Time Zone Rule Set whether to log local time You will notice that the menu definition contains a complete sub-menu for the WiFi and NTP settings (note the SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START ): // WiFi sub-menu: set the WiFi SSID and password mySensors . theMenu . addMenuItem ( \"WiFi Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START ); // Start of the WiFi sub-menu mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"WiFi Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"=========\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"WiFi SSID\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"WiFi SSID\" , \"T-Rex\" ); // Set the default SSID - this will be updated by readLoggerConfig mySensors . theMenu . addMenuItem ( \"WiFi password\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"WiFi password\" , \"Has Big Teeth\" ); // Set the default password - this will be updated by readLoggerConfig mySensors . theMenu . addMenuItem ( \"NTP Server 1\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"NTP Server 1\" , \"pool.ntp.org\" ); mySensors . theMenu . addMenuItem ( \"NTP Server 2\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"NTP Server 2\" , \"time.nist.gov\" ); mySensors . theMenu . addMenuItem ( \"TimeZone Rule\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"TimeZone Rule\" , \"MST7MDT,M3.2.0,M11.1.0\" ); // TimeZone rule for America/Denver mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"A list of rules for your time zone can be obtained from:\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_END ); // End of the WiFi sub-menu The sub-menu contains several SFE_QUAD_MENU_VARIABLE_TYPE_TEXT items to hold: The WiFi SSID (the name of the WiFi network you want to connect to) The WiFi password The names of the NTP servers The Time Zone Rule (which will automatically set the RTC to local time and adjust for daylight saving) The setMenuItemVariable lines define the default / initial values for the text items. But, again, these can be updated via the menu or by reading the configuration from SD card. The WiFi sub-menu is opened by selecting option 8 from the main menu: Menu ==== 1 : Open the sensor logging menu 2 : Open the sensor settings menu 3 : Open new log file 4 : Stop logging 5 : Set RTC using NTP over WiFi 6 : Write the logger configuration to file 7 : Read the logger configuration from file 8 : WiFi Menu 9 : Logging Menu Enter a number, or enter 0 to exit: 8 WiFi Menu ========= 1 : WiFi SSID : T-Rex 2 : WiFi password : Has Big Teeth 3 : NTP Server 1 : pool.ntp.org 4 : NTP Server 2 : time.nist.gov 5 : TimeZone Rule : MST7MDT,M3.2.0,M11.1.0 A list of rules for your time zone can be obtained from: https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h Enter a number, or enter 0 to exit: To change (e.g.) the name of NTP Server 1, select option 3 and then enter the new name: WiFi Menu ========= 1 : WiFi SSID : T-Rex 2 : WiFi password : Has Big Teeth 3 : NTP Server 1 : pool.ntp.org 4 : NTP Server 2 : time.nist.gov 5 : TimeZone Rule : MST7MDT,M3.2.0,M11.1.0 A list of rules for your time zone can be obtained from: https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h Enter a number, or enter 0 to exit: 3 Enter the value (text): europe.pool.ntp.org WiFi Menu ========= 1 : WiFi SSID : T-Rex 2 : WiFi password : Has Big Teeth 3 : NTP Server 1 : europe.pool.ntp.org 4 : NTP Server 2 : time.nist.gov 5 : TimeZone Rule : MST7MDT,M3.2.0,M11.1.0 A list of rules for your time zone can be obtained from: https://github.com/esp8266/Arduino/blob/master/cores/esp8266/TZ.h Enter a number, or enter 0 to exit: As before, the updated settings can be saved to SD card with main menu option 6. If you are using a terminal emulator, like Tera Term, you may want to enable backspace support. This allows you to edit existing TEXT values without having to re-enter the whole text each time. // The Arduino IDE Serial Monitor does not support backspace so - by default - we need to clear text values when editing them. // The user enters the entire text value each time. // If the user is using a terminal emulator which supports backspace (e.g. Tera Term) then // setting supportsBackspace to true will allow the existing text to be edited. mySensors . theMenu . setMenuPort ( serialQUAD , true ); // Uncomment this line to use serialQUAD for the menu - on a terminal emulator which supports backspace","title":"The Menu"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#setting-the-rtc","text":"Setting the RTC is a two-step process: The ESP32 connects to WiFi The ESP32 requests network time from the NTP server(s) and sets the RTC accordingly (using the Time Zone Rule) The code in setRTC() is taken mostly from Espressif's SimpleTime example. The WiFi SSID and password are copied from the menu linked-list into char arrays ssid and password . The WiFi.begin then uses the copies: char ssid [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi SSID\" , ssid , 32 ); char password [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi password\" , password , 32 ); serialQUAD . printf ( \"Connecting to %s \" , ssid ); WiFi . begin ( ssid , password ); const unsigned long wifiConnectTimeout = 10000 ; // Allow 10s for WiFi connection unsigned long startTime = millis (); while (( WiFi . status () != WL_CONNECTED ) && ( millis () < ( startTime + wifiConnectTimeout ))) { delay ( 500 ); serialQUAD . print ( \".\" ); } The names of the NTP servers and the Time Zone Rule are copied and passed into configTzTime : char time_zone [ 50 ]; mySensors . theMenu . getMenuItemVariable ( \"TimeZone Rule\" , time_zone , 50 ); char ntpServer1 [ 20 ]; mySensors . theMenu . getMenuItemVariable ( \"NTP Server 1\" , ntpServer1 , 20 ); char ntpServer2 [ 20 ]; mySensors . theMenu . getMenuItemVariable ( \"NTP Server 2\" , ntpServer2 , 20 ); configTzTime ( time_zone , ntpServer1 , ntpServer2 ); There is no function call to specifically set the RTC, it is handled automatically when getLocalTime is requested: if ( WiFi . status () == WL_CONNECTED ) { serialQUAD . println ( \" CONNECTED\" ); struct tm timeinfo ; // Doing a getLocalTime immediately after the WiFi connects seems critical to NTP being successful?! getLocalTime ( & timeinfo ); } In this example, the WiFi connection is only used to set the RTC, so the WiFi connection is closed once getLocalTime returns.","title":"Setting the RTC"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#log-local-time","text":"By default, the RTC local time will be included in the log file. But you can disable it if you want to. The Logging Sub-Menu includes a bool (boolean) item called Log Local Time : mySensors . theMenu . addMenuItem ( \"Log Local Time\" , SFE_QUAD_MENU_VARIABLE_TYPE_BOOL ); defaultValue . BOOL = 1 ; mySensors . theMenu . setMenuItemVariable ( \"Log Local Time\" , & defaultValue ); In the loop() , Log Local Time controls if the local time is printed and added to the log file (before mySensors.readings ): SFE_QUAD_Menu_Every_Type_t logLocalTime ; mySensors . theMenu . getMenuItemVariable ( \"Log Local Time\" , & logLocalTime ); if ( logLocalTime . BOOL ) printLocalTime ( serialQUAD ); // Print local time if desired serialQUAD . println ( mySensors . readings ); // Print the sensor readings if ( onlineDataLogging ) { digitalWrite ( LED_BUILTIN , HIGH ); if ( logLocalTime . BOOL ) printLocalTime ( sensorDataFile ); // Write local time to the file if desired sensorDataFile . println ( mySensors . readings ); // Write the data to file The helper function printLocalTime prints the RTC time to Serial or the log file in YYYY/MM/DD HH:MM:SS format: void printLocalTime ( Print & pr ) { // getLocalTime stalls for several seconds if the RTC has not been set (using NTP) // Use gettimeofday instead (and manually convert to tm) struct timeval tv ; struct timezone tz ; gettimeofday ( & tv , & tz ); time_t t = ( time_t ) tv . tv_sec ; struct tm * timeinfo ; timeinfo = localtime ( & t ); pr . print ( timeinfo , \"%Y/%m/%d %H:%M:%S,\" ); }","title":"Log Local Time"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_07_Thing_Plus_C_Logger_RTC/#log-file-timestamps","text":"This example includes two new support functions: updateDataFileCreate and updateDataFileAccess . These make use of SdFat's timestamp method to set the log file creation and write times to local (RTC) time. When you look at the directory of the microSD card on your computer, you will notice that the file times and dates are correct.","title":"Log File Timestamps"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/","text":"Example 8 - ESP32 Thing Plus C ThingSpeak Publish - Publishing sensor data to ThingSpeak A more complex example to show how to publish sensor data to ThingSpeak using SparkFun Qwiic Universal Auto-Detect. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for other ESP32 platforms. Key Features Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the WiFi SSID and password through the menu system Configuring the sensor settings through the menu Publishing the sensor readings to ThingSpeak Writing the settings to EEPROM Reading the settings back from EEPROM This example is very similar to Example7 . Please see the Example 1, 6 and 7 documentation for a full walk-through of the code. Let's walk through the key differences: EEPROM In this example, we store the sensor and menu settings in EEPROM, instead of on microSD card. We don't need the microSD card as this example as not logging any data as such, the sensor data is uploaded to ThingSpeak and they log it for us. (This allows this example to run on ESP32 boards which don't have microSD on-board!) #include <EEPROM.h> // Include EEPROM.h to enable support for SFE_QUAD_Sensors__EEPROM. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect SFE_QUAD_Sensors__EEPROM mySensors ; ThingSpeak ThingSpeak from MathWorks is an IoT analytics platform service that allows you to aggregate, visualize, and analyze live data streams in the cloud. SparkFun has been a fan of ThingSpeak for many years . ThingSpeak have made life really easy for us by providing an Arduino Library which lets you upload your data straight to your ThingSpeak channel. You can then view the analytics on your phone or computer, privately or publicly. You can install the ThingSpeak library through the Arduino IDE Library Manager: search for ThingSpeak . #include <ThingSpeak.h> // Click here to get the library: http://librarymanager/All#ThingSpeak ThingSpeak uses an ESP32 WiFiClient to upload the data: #include <WiFi.h> WiFiClient myClient ; In setup() : WiFi . mode ( WIFI_STA ); ThingSpeak . begin ( myClient ); // Initialize ThingSpeak The Menu ThingSpeak requires a Write API Key (essentially an encrypted username and password) and your Channel ID . These are available once you have set up a (free) account and have created a channel: Each Channel ID can have up to eight \"fields\". In this example, the code uploads the first (up to) eight sense readings to whichever ThingSpeak channel you select. The Write API Key and Channel ID are of course stored in the menu, together with the Publish interval (ms) : // ThingSpeak sub-menu: set the publish interval etc. mySensors . theMenu . addMenuItem ( \"ThingSpeak Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"ThingSpeak Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"============\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"Write API Key\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"Write API Key\" , \"REPLACE_WITH_YOUR_KEY\" ); // Set the default API Key - this will be updated by readLoggerConfig mySensors . theMenu . addMenuItem ( \"Channel ID\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); SFE_QUAD_Menu_Every_Type_t defaultValue ; defaultValue . ULONG = 1 ; mySensors . theMenu . setMenuItemVariable ( \"Channel ID\" , & defaultValue ); // Set the default channel number mySensors . theMenu . addMenuItem ( \"Publish interval (ms)\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); defaultValue . ULONG = 60000 ; mySensors . theMenu . setMenuItemVariable ( \"Publish interval (ms)\" , & defaultValue ); // Set the default publish interval defaultValue . ULONG = 15000 ; mySensors . theMenu . setMenuItemVariableMin ( \"Publish interval (ms)\" , & defaultValue ); // Minimum interval is 15 seconds defaultValue . ULONG = 3600000 ; mySensors . theMenu . setMenuItemVariableMax ( \"Publish interval (ms)\" , & defaultValue ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_END ); // End of the sub-menu Write API Key is SFE_QUAD_MENU_VARIABLE_TYPE_TEXT Channel ID is SFE_QUAD_MENU_VARIABLE_TYPE_ULONG (unisgned long) Publish interval (ms) is also SFE_QUAD_MENU_VARIABLE_TYPE_ULONG (unisgned long) The fastest you can send data to ThingSpeak is once every 15 seconds, so we set the minimum Publish interval (ms) to 15000. Publishing the Sense Readings The code uses the ThingSpeak setField and writeFields methods to upload up to eight sense readings to your channel. // ThingSpeak channels can have up to 8 fields // Extract up to 8 Strings from mySensors.readings using strtok_r unsigned int fieldNum = 1 ; char * preserve ; char * field = strtok_r ( mySensors . readings , \",\" , & preserve ); // Separate the CSV data into keys at each comma int result = TS_OK_SUCCESS ; while (( field != NULL ) && ( fieldNum <= 8 ) && ( result == TS_OK_SUCCESS )) { if (( strchr ( field , 'e' ) != NULL ) || ( strchr ( field , 'E' ) != NULL )) // Does field contain exponent-format data? { double val ; if ( mySensors . _sprintf . expStrToDouble ( field , & val )) // Convert exponent-format string to double result = ThingSpeak . setField ( fieldNum , ( float ) val ); // Cast double to float else result = TS_ERR_NOT_INSERTED ; } else result = ThingSpeak . setField ( fieldNum , String ( field )); // Use the string-format data as-is The channel ID and API key are copied from the menu and included in the call to writeFields : SFE_QUAD_Menu_Every_Type_t channelNumber ; mySensors . theMenu . getMenuItemVariable ( \"Channel ID\" , & channelNumber ); // Get the channel number char myWriteAPIKey [ 33 ]; mySensors . theMenu . getMenuItemVariable ( \"Write API Key\" , myWriteAPIKey , 33 ); result = ThingSpeak . writeFields ( channelNumber . ULONG , myWriteAPIKey ); WiFi Connection The ESP32 WiFi of course needs to be connected so the sensor readings can be uploaded. Periodically the WiFi connection may drop out and need to be re-connected. The code therefore includes a wifiConnect() helper which will (re)connect if required using the SSID and password from the menu: // Connect to WiFi void wifiConnect ( void ) { if ( WiFi . status () == WL_CONNECTED ) { serialQUAD . println ( \"WiFi is already connected! Disconnecting...\" ); WiFi . disconnect ( true ); WiFi . mode ( WIFI_OFF ); delay ( 5000 ); } char ssid [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi SSID\" , ssid , 32 ); char password [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi password\" , password , 32 ); serialQUAD . printf ( \"Connecting to %s \" , ssid ); WiFi . begin ( ssid , password ); const unsigned long wifiConnectTimeout = 10000 ; // Allow 10s for WiFi connection unsigned long startTime = millis (); while (( WiFi . status () != WL_CONNECTED ) && ( millis () < ( startTime + wifiConnectTimeout ))) { delay ( 500 ); serialQUAD . print ( \".\" ); } if ( WiFi . status () == WL_CONNECTED ) serialQUAD . println ( \" CONNECTED\" ); else serialQUAD . println ( \" Connection failed! Please try again...\" ); } ThingSpeak Charts Once your data is being written to ThingSpeak, it is easy to create charts of the sensor readings:","title":"Example 8 - Thing Plus C Logger ThingSpeak Publish"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#example-8-esp32-thing-plus-c-thingspeak-publish-publishing-sensor-data-to-thingspeak","text":"A more complex example to show how to publish sensor data to ThingSpeak using SparkFun Qwiic Universal Auto-Detect. This example was written for the SparkFun ESP32 Thing Plus C (SPX-18018) but can be adapted for other ESP32 platforms.","title":"Example 8 - ESP32 Thing Plus C ThingSpeak Publish - Publishing sensor data to ThingSpeak"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#key-features","text":"Declaring a SFE_QUAD_Sensors object Detecting which sensors are connected Initializing the sensors Setting up a menu Configuring the WiFi SSID and password through the menu system Configuring the sensor settings through the menu Publishing the sensor readings to ThingSpeak Writing the settings to EEPROM Reading the settings back from EEPROM This example is very similar to Example7 . Please see the Example 1, 6 and 7 documentation for a full walk-through of the code. Let's walk through the key differences:","title":"Key Features"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#eeprom","text":"In this example, we store the sensor and menu settings in EEPROM, instead of on microSD card. We don't need the microSD card as this example as not logging any data as such, the sensor data is uploaded to ThingSpeak and they log it for us. (This allows this example to run on ESP32 boards which don't have microSD on-board!) #include <EEPROM.h> // Include EEPROM.h to enable support for SFE_QUAD_Sensors__EEPROM. Do this before #include \"SFE_QUAD_Sensors.h\" #include \"SFE_QUAD_Sensors.h\" // Click here to get the library: http://librarymanager/All#SparkFun_Qwiic_Universal_Auto-Detect SFE_QUAD_Sensors__EEPROM mySensors ;","title":"EEPROM"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#thingspeak","text":"ThingSpeak from MathWorks is an IoT analytics platform service that allows you to aggregate, visualize, and analyze live data streams in the cloud. SparkFun has been a fan of ThingSpeak for many years . ThingSpeak have made life really easy for us by providing an Arduino Library which lets you upload your data straight to your ThingSpeak channel. You can then view the analytics on your phone or computer, privately or publicly. You can install the ThingSpeak library through the Arduino IDE Library Manager: search for ThingSpeak . #include <ThingSpeak.h> // Click here to get the library: http://librarymanager/All#ThingSpeak ThingSpeak uses an ESP32 WiFiClient to upload the data: #include <WiFi.h> WiFiClient myClient ; In setup() : WiFi . mode ( WIFI_STA ); ThingSpeak . begin ( myClient ); // Initialize ThingSpeak","title":"ThingSpeak"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#the-menu","text":"ThingSpeak requires a Write API Key (essentially an encrypted username and password) and your Channel ID . These are available once you have set up a (free) account and have created a channel: Each Channel ID can have up to eight \"fields\". In this example, the code uploads the first (up to) eight sense readings to whichever ThingSpeak channel you select. The Write API Key and Channel ID are of course stored in the menu, together with the Publish interval (ms) : // ThingSpeak sub-menu: set the publish interval etc. mySensors . theMenu . addMenuItem ( \"ThingSpeak Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_START ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"ThingSpeak Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"============\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"Write API Key\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); mySensors . theMenu . setMenuItemVariable ( \"Write API Key\" , \"REPLACE_WITH_YOUR_KEY\" ); // Set the default API Key - this will be updated by readLoggerConfig mySensors . theMenu . addMenuItem ( \"Channel ID\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); SFE_QUAD_Menu_Every_Type_t defaultValue ; defaultValue . ULONG = 1 ; mySensors . theMenu . setMenuItemVariable ( \"Channel ID\" , & defaultValue ); // Set the default channel number mySensors . theMenu . addMenuItem ( \"Publish interval (ms)\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); defaultValue . ULONG = 60000 ; mySensors . theMenu . setMenuItemVariable ( \"Publish interval (ms)\" , & defaultValue ); // Set the default publish interval defaultValue . ULONG = 15000 ; mySensors . theMenu . setMenuItemVariableMin ( \"Publish interval (ms)\" , & defaultValue ); // Minimum interval is 15 seconds defaultValue . ULONG = 3600000 ; mySensors . theMenu . setMenuItemVariableMax ( \"Publish interval (ms)\" , & defaultValue ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); mySensors . theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_SUB_MENU_END ); // End of the sub-menu Write API Key is SFE_QUAD_MENU_VARIABLE_TYPE_TEXT Channel ID is SFE_QUAD_MENU_VARIABLE_TYPE_ULONG (unisgned long) Publish interval (ms) is also SFE_QUAD_MENU_VARIABLE_TYPE_ULONG (unisgned long) The fastest you can send data to ThingSpeak is once every 15 seconds, so we set the minimum Publish interval (ms) to 15000.","title":"The Menu"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#publishing-the-sense-readings","text":"The code uses the ThingSpeak setField and writeFields methods to upload up to eight sense readings to your channel. // ThingSpeak channels can have up to 8 fields // Extract up to 8 Strings from mySensors.readings using strtok_r unsigned int fieldNum = 1 ; char * preserve ; char * field = strtok_r ( mySensors . readings , \",\" , & preserve ); // Separate the CSV data into keys at each comma int result = TS_OK_SUCCESS ; while (( field != NULL ) && ( fieldNum <= 8 ) && ( result == TS_OK_SUCCESS )) { if (( strchr ( field , 'e' ) != NULL ) || ( strchr ( field , 'E' ) != NULL )) // Does field contain exponent-format data? { double val ; if ( mySensors . _sprintf . expStrToDouble ( field , & val )) // Convert exponent-format string to double result = ThingSpeak . setField ( fieldNum , ( float ) val ); // Cast double to float else result = TS_ERR_NOT_INSERTED ; } else result = ThingSpeak . setField ( fieldNum , String ( field )); // Use the string-format data as-is The channel ID and API key are copied from the menu and included in the call to writeFields : SFE_QUAD_Menu_Every_Type_t channelNumber ; mySensors . theMenu . getMenuItemVariable ( \"Channel ID\" , & channelNumber ); // Get the channel number char myWriteAPIKey [ 33 ]; mySensors . theMenu . getMenuItemVariable ( \"Write API Key\" , myWriteAPIKey , 33 ); result = ThingSpeak . writeFields ( channelNumber . ULONG , myWriteAPIKey );","title":"Publishing the Sense Readings"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#wifi-connection","text":"The ESP32 WiFi of course needs to be connected so the sensor readings can be uploaded. Periodically the WiFi connection may drop out and need to be re-connected. The code therefore includes a wifiConnect() helper which will (re)connect if required using the SSID and password from the menu: // Connect to WiFi void wifiConnect ( void ) { if ( WiFi . status () == WL_CONNECTED ) { serialQUAD . println ( \"WiFi is already connected! Disconnecting...\" ); WiFi . disconnect ( true ); WiFi . mode ( WIFI_OFF ); delay ( 5000 ); } char ssid [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi SSID\" , ssid , 32 ); char password [ 32 ]; mySensors . theMenu . getMenuItemVariable ( \"WiFi password\" , password , 32 ); serialQUAD . printf ( \"Connecting to %s \" , ssid ); WiFi . begin ( ssid , password ); const unsigned long wifiConnectTimeout = 10000 ; // Allow 10s for WiFi connection unsigned long startTime = millis (); while (( WiFi . status () != WL_CONNECTED ) && ( millis () < ( startTime + wifiConnectTimeout ))) { delay ( 500 ); serialQUAD . print ( \".\" ); } if ( WiFi . status () == WL_CONNECTED ) serialQUAD . println ( \" CONNECTED\" ); else serialQUAD . println ( \" Connection failed! Please try again...\" ); }","title":"WiFi Connection"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_08_Thing_Plus_C_ThingSpeak/#thingspeak-charts","text":"Once your data is being written to ThingSpeak, it is easy to create charts of the sensor readings:","title":"ThingSpeak Charts"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_09_Menu_Memory_Leak_Test/","text":"Example 9 - Menu Memory Leak Test - How to test for a menu memory leak In Example5 , we learned how to test the SFE_QUAD_Sensors class for a memory leak, by declaring the SparkFun Qwiic Universal Auto-Detect object mySensors inside the loop() . This example does the same thing but for the SFE_QUAD_Menu class. We run it on a RedBoard to make sure the library menus have no memory leaks. (Actually, we did find one in the TEXT variable - and we fixed it!) The code only includes the SFE_QUAD_Menus header file, not the full SFE_QUAD_Sensors header: #include \"SFE_QUAD_Menus.h\" In this example, the theMenu object is destructed and (re)instantiated each time the code goes around the loop() : void loop () { SFE_QUAD_Menu theMenu ; theMenu . setMenuPort ( Serial ); theMenu . setDebugPort ( Serial ); theMenu . setMenuTimeout ( 1000 ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"====\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"Toggle the LED\" , blink ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"TEXT\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); theMenu . addMenuItem ( \"BOOL\" , SFE_QUAD_MENU_VARIABLE_TYPE_BOOL ); theMenu . addMenuItem ( \"FLOAT\" , SFE_QUAD_MENU_VARIABLE_TYPE_FLOAT ); theMenu . addMenuItem ( \"DOUBLE\" , SFE_QUAD_MENU_VARIABLE_TYPE_DOUBLE ); theMenu . addMenuItem ( \"INT\" , SFE_QUAD_MENU_VARIABLE_TYPE_INT ); theMenu . addMenuItem ( \"ULONG\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); theMenu . addMenuItem ( \"LONG\" , SFE_QUAD_MENU_VARIABLE_TYPE_LONG ); theMenu . addMenuItem ( \"UINT8_T\" , SFE_QUAD_MENU_VARIABLE_TYPE_UINT8_T ); theMenu . addMenuItem ( \"UINT16_T\" , SFE_QUAD_MENU_VARIABLE_TYPE_UINT16_T ); theMenu . addMenuItem ( \"UINT32_T\" , SFE_QUAD_MENU_VARIABLE_TYPE_UINT32_T ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); SFE_QUAD_Menu_Every_Type_t defaultValue ; defaultValue . BOOL = 0 ; defaultValue . FLOAT = 1.0 ; defaultValue . DOUBLE = -2.0 ; defaultValue . INT = -3 ; defaultValue . ULONG = 4 ; defaultValue . LONG = -5 ; defaultValue . UINT8_T = 6 ; defaultValue . UINT16_T = 7 ; defaultValue . UINT32_T = 8 ; theMenu . setMenuItemVariable ( \"TEXT\" , \"T-Rex has big teeth\" ); theMenu . setMenuItemVariable ( \"BOOL\" , & defaultValue ); theMenu . setMenuItemVariable ( \"FLOAT\" , & defaultValue ); theMenu . setMenuItemVariable ( \"DOUBLE\" , & defaultValue ); theMenu . setMenuItemVariable ( \"INT\" , & defaultValue ); theMenu . setMenuItemVariable ( \"ULONG\" , & defaultValue ); theMenu . setMenuItemVariable ( \"LONG\" , & defaultValue ); theMenu . setMenuItemVariable ( \"UINT8_T\" , & defaultValue ); theMenu . setMenuItemVariable ( \"UINT16_T\" , & defaultValue ); theMenu . setMenuItemVariable ( \"UINT32_T\" , & defaultValue ); theMenu . openMenu (); }","title":"Example 9 - Menu Memory Leak Test"},{"location":"sparkfun-qwiic-universal-auto-detect-examples/ex_09_Menu_Memory_Leak_Test/#example-9-menu-memory-leak-test-how-to-test-for-a-menu-memory-leak","text":"In Example5 , we learned how to test the SFE_QUAD_Sensors class for a memory leak, by declaring the SparkFun Qwiic Universal Auto-Detect object mySensors inside the loop() . This example does the same thing but for the SFE_QUAD_Menu class. We run it on a RedBoard to make sure the library menus have no memory leaks. (Actually, we did find one in the TEXT variable - and we fixed it!) The code only includes the SFE_QUAD_Menus header file, not the full SFE_QUAD_Sensors header: #include \"SFE_QUAD_Menus.h\" In this example, the theMenu object is destructed and (re)instantiated each time the code goes around the loop() : void loop () { SFE_QUAD_Menu theMenu ; theMenu . setMenuPort ( Serial ); theMenu . setDebugPort ( Serial ); theMenu . setMenuTimeout ( 1000 ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"Menu\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"====\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"Toggle the LED\" , blink ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); theMenu . addMenuItem ( \"TEXT\" , SFE_QUAD_MENU_VARIABLE_TYPE_TEXT ); theMenu . addMenuItem ( \"BOOL\" , SFE_QUAD_MENU_VARIABLE_TYPE_BOOL ); theMenu . addMenuItem ( \"FLOAT\" , SFE_QUAD_MENU_VARIABLE_TYPE_FLOAT ); theMenu . addMenuItem ( \"DOUBLE\" , SFE_QUAD_MENU_VARIABLE_TYPE_DOUBLE ); theMenu . addMenuItem ( \"INT\" , SFE_QUAD_MENU_VARIABLE_TYPE_INT ); theMenu . addMenuItem ( \"ULONG\" , SFE_QUAD_MENU_VARIABLE_TYPE_ULONG ); theMenu . addMenuItem ( \"LONG\" , SFE_QUAD_MENU_VARIABLE_TYPE_LONG ); theMenu . addMenuItem ( \"UINT8_T\" , SFE_QUAD_MENU_VARIABLE_TYPE_UINT8_T ); theMenu . addMenuItem ( \"UINT16_T\" , SFE_QUAD_MENU_VARIABLE_TYPE_UINT16_T ); theMenu . addMenuItem ( \"UINT32_T\" , SFE_QUAD_MENU_VARIABLE_TYPE_UINT32_T ); theMenu . addMenuItem ( \"\" , SFE_QUAD_MENU_VARIABLE_TYPE_NONE ); SFE_QUAD_Menu_Every_Type_t defaultValue ; defaultValue . BOOL = 0 ; defaultValue . FLOAT = 1.0 ; defaultValue . DOUBLE = -2.0 ; defaultValue . INT = -3 ; defaultValue . ULONG = 4 ; defaultValue . LONG = -5 ; defaultValue . UINT8_T = 6 ; defaultValue . UINT16_T = 7 ; defaultValue . UINT32_T = 8 ; theMenu . setMenuItemVariable ( \"TEXT\" , \"T-Rex has big teeth\" ); theMenu . setMenuItemVariable ( \"BOOL\" , & defaultValue ); theMenu . setMenuItemVariable ( \"FLOAT\" , & defaultValue ); theMenu . setMenuItemVariable ( \"DOUBLE\" , & defaultValue ); theMenu . setMenuItemVariable ( \"INT\" , & defaultValue ); theMenu . setMenuItemVariable ( \"ULONG\" , & defaultValue ); theMenu . setMenuItemVariable ( \"LONG\" , & defaultValue ); theMenu . setMenuItemVariable ( \"UINT8_T\" , & defaultValue ); theMenu . setMenuItemVariable ( \"UINT16_T\" , & defaultValue ); theMenu . setMenuItemVariable ( \"UINT32_T\" , & defaultValue ); theMenu . openMenu (); }","title":"Example 9 - Menu Memory Leak Test - How to test for a menu memory leak"}]}